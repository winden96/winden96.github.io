<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP和HTTPS | winden96</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="winden96 的学习记录">
    
    <link rel="preload" href="/assets/css/0.styles.4fd6cf0c.css" as="style"><link rel="preload" href="/assets/js/app.e7c2969b.js" as="script"><link rel="preload" href="/assets/js/2.94d3dfac.js" as="script"><link rel="preload" href="/assets/js/30.be0b3d6d.js" as="script"><link rel="prefetch" href="/assets/js/10.27cdeca9.js"><link rel="prefetch" href="/assets/js/11.07a9d483.js"><link rel="prefetch" href="/assets/js/12.2505f188.js"><link rel="prefetch" href="/assets/js/13.0d8bcb67.js"><link rel="prefetch" href="/assets/js/14.a1698ea2.js"><link rel="prefetch" href="/assets/js/15.dce506f4.js"><link rel="prefetch" href="/assets/js/16.82ab8250.js"><link rel="prefetch" href="/assets/js/17.1fa3722a.js"><link rel="prefetch" href="/assets/js/18.129b810d.js"><link rel="prefetch" href="/assets/js/19.7531d5a3.js"><link rel="prefetch" href="/assets/js/20.2c5f040e.js"><link rel="prefetch" href="/assets/js/21.635435c4.js"><link rel="prefetch" href="/assets/js/22.a44576c7.js"><link rel="prefetch" href="/assets/js/23.32ee5f65.js"><link rel="prefetch" href="/assets/js/24.109d908c.js"><link rel="prefetch" href="/assets/js/25.9ebc3e07.js"><link rel="prefetch" href="/assets/js/26.643e2283.js"><link rel="prefetch" href="/assets/js/27.44aebb00.js"><link rel="prefetch" href="/assets/js/28.269bc50f.js"><link rel="prefetch" href="/assets/js/29.5ba9d11a.js"><link rel="prefetch" href="/assets/js/3.dc23a8fe.js"><link rel="prefetch" href="/assets/js/31.5c853594.js"><link rel="prefetch" href="/assets/js/32.06dd5c8a.js"><link rel="prefetch" href="/assets/js/33.66017b72.js"><link rel="prefetch" href="/assets/js/4.76c25a36.js"><link rel="prefetch" href="/assets/js/5.313f4ba0.js"><link rel="prefetch" href="/assets/js/6.3db81792.js"><link rel="prefetch" href="/assets/js/7.2b7d8442.js"><link rel="prefetch" href="/assets/js/8.19d8ddaf.js"><link rel="prefetch" href="/assets/js/9.4cbab228.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4fd6cf0c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">winden96</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>My SQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Boot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Cloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>杂记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>消息中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机网络</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/计算机网络/GET和POST的区别.html" class="sidebar-link">GET和POST的区别</a></li><li><a href="/计算机网络/HTTP和HTTPS.html" aria-current="page" class="active sidebar-link">HTTP和HTTPS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/计算机网络/HTTP和HTTPS.html#https" class="sidebar-link">HTTPS</a></li></ul></li><li><a href="/计算机网络/TCP和UDP.html" class="sidebar-link">TCP和UDP</a></li><li><a href="/计算机网络/输入网址之后发生了什么.html" class="sidebar-link">输入网址之后发生了什么</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http1-0和http1-1、http2-0有什么区别"><a href="#http1-0和http1-1、http2-0有什么区别" class="header-anchor">#</a> HTTP1.0和HTTP1.1、HTTP2.0有什么区别？</h1> <blockquote><p>首先HTTP1.0和HTTP1.1的区别</p></blockquote> <ul><li><strong>缓存处理</strong> ，在<strong>HTTP1.0中主要使⽤header⾥的If-Modified-Since,Expires来做为缓存判断的标准，</strong> <strong>HTTP1.1则引⼊了更多的缓存控制策略</strong>例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match
等更多可供选择的缓存头来控制缓存策略。</li> <li><strong>带宽优化及⽹络连接的使⽤</strong>，HTTP1.0中，存在⼀些浪费带宽的现象，例如客户端只是需要某个对象
的⼀部分，⽽<strong>服务器却将整个对象送过来了，并且不⽀持断点续传功能</strong>，<strong>HTTP1.1则在请求头引⼊了
range头域，它允许只请求资源的某个部分，即返回码是206</strong>（Partial Content），这样就⽅便了开发
者⾃由的选择以便于充分利⽤带宽和连接。</li> <li><strong>错误通知的管理</strong>，在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如409（Conflict）表示请求的资源与资
源的当前状态发⽣冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li> <li><strong>Host头处理</strong>，在<strong>HTTP1.0中认为每台服务器都绑定⼀个唯⼀的IP地址</strong>，因此，请求消息中的URL并没
有传递主机名（hostname）。但随着虚拟主机技术的发展，在⼀台物理服务器上可以存在多个虚拟主
机（Multi-homed Web Servers），并且它们共享⼀个IP地址。<strong>HTTP1.1的请求消息和响应消息都应⽀
持Host头域，且请求消息中如果没有Host头域会报告⼀个错误（400 Bad Request）</strong>。</li> <li><strong>⻓连接</strong>，<strong>HTTP 1.1⽀持⻓连接（PersistentConnection）和请求的流⽔线（Pipelining）处理，在⼀个
TCP连接上可以传送多个HTTP请求和响应，减少了建⽴和关闭连接的消耗和延迟</strong>，在HTTP1.1中默认
开启Connection：<strong>keep-alive</strong>，⼀定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li></ul> <blockquote><p><strong>HTTP2.0和HTTP1.X相比的新特性</strong></p></blockquote> <ul><li><strong>新的二进制格式</strong>（Binary Format），<strong>HTTP1.x的解析是基于文本</strong>。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑<strong>HTTP2.0的协议解析决定采用二进制格式</strong>，实现方便且健壮。</li> <li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li> <li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，<strong>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表</strong>，既避免了重复header的传输，又减小了需要传输的大小。</li> <li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ul> <blockquote><p>补充：</p></blockquote> <p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p> <ul><li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li> <li>HTTP/1.1 Pipeling解决方式为，<strong>若干个请求排队串行化单线程处理</strong>，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li> <li>HTTP/2多个请求可<strong>同时在一个连接上并行执行</strong>。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li></ul> <p><strong>关于⻓连接和短连接的理解及使⽤场景</strong></p> <ul><li><p>短连接：例如<strong>普通的web请求</strong>，在三次握⼿之后建⽴连接，发送数据包并得到服务器返回的结果之
后，通过客户端和服务端的四次握⼿进⾏关闭断开。</p></li> <li><p>⻓连接：区别于短连接，由于三次握⼿链接及四次握⼿断开，在请求频繁的情况下，链接请求和断开
请求的开销较⼤，影响效率。采⽤⻓连接⽅式，<strong>执⾏三次握⼿链接后，不断开链接，保持客户端和服
务端通信，直到服务器超时⾃动断开链接，或者客户端主动断开链接。</strong></p> <p>适⽤场景：
短连接：适⽤于⽹⻚浏览等数据刷新频度较低的场景。
⻓连接：适⽤于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等。</p></li></ul> <h1 id="http-和-https的区别"><a href="#http-和-https的区别" class="header-anchor">#</a> HTTP 和 HTTPS的区别？</h1> <p>HTTPS与HTTP的⼀些区别
HTTPS协议需要到CA申请证书，⼀般免费证书很少，需要交费。
HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，HTTPS运⾏在SSL/TLS之上，SSL/TLS运⾏在
TCP之上，所有传输的内容都经过加密的。
HTTP和HTTPS使⽤的是完全不同的连接⽅式，⽤的端⼝也不⼀样，前者是80，后者是443。
HTTPS可以有效的防⽌运营商劫持，解决了防劫持的⼀个⼤问题。</p> <h1 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h1> <p>http是一种无状态协议。无状态是指客户机和服务器之间不需要建立持久连接，这意味着当一个客户端向服务器发出请求，然后服务器返回响应（response），连接就被关闭了，在服务器端不保留连接的有关信息，HTTP遵循请求/应答模型。客户机向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都构成一套请求和应答。</p> <h2 id="https"><a href="#https" class="header-anchor">#</a> HTTPS</h2> <p>HTTPS是以安全为目标的HTTP通道，简单将就是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口是443，过程大致如下：</p> <h3 id="获取连接证书"><a href="#获取连接证书" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener noreferrer">获取连接证书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>SSL客户端通过TCP和服务器建立连接后（443端口），并且在一般的TCP连接协商过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共密钥）</p> <h3 id="证书验证"><a href="#证书验证" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener noreferrer">证书验证<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共密钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名</p> <h3 id="数据加密和传输"><a href="#数据加密和传输" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%92%8C%E4%BC%A0%E8%BE%93" target="_blank" rel="noopener noreferrer">数据加密和传输<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>如果确认证书有效，那么生成对称密钥并使用服务器的公共密钥进行加密。然后发送给服务器，服务器使用它的密钥进行解密，这样两台计算机可以开始进行对称加密进行通信。</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413085448943.png" alt="image-20200413085448943"></p> <p>对称加密：是指加密和解密用的都是同一个密钥，目前微信小程序采用的就是这个加密方式</p> <h3 id="对称加密存在的问题"><a href="#对称加密存在的问题" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">对称加密存在的问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>首先我们知道对称加密是指：加密和解密都使用的同一个密钥，这种方式存在的最大的问题就是密钥发送问题，即如果安全的将密钥发送给对方。</p> <h4 id="为什么叫对称加密"><a href="#为什么叫对称加密" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%9F" target="_blank" rel="noopener noreferrer">为什么叫对称加密？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>一方通过密钥将信息加密后，把密文传给另一个方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系如下</p> <blockquote><p>明文 -&gt; 密钥 -&gt; 密文</p></blockquote> <p>但是从上面的图我们可以看出，我们在进行加密后，首先需要将密钥发送给服务器，那么这个过程就可能存在危险的</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413091318404.png" alt="image-20200413091318404"></p> <h3 id="非对称加密"><a href="#非对称加密" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener noreferrer">非对称加密<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>上面提到的是对称加密，其实还有一种是非对称加密，非对称加密是通过两个密钥（公钥 - 私钥）来实现对数据的加密和解密的，公钥用于加密，私钥用于解密。</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413085937800.png" alt="image-20200413085937800"></p> <p>过程如下：</p> <p>首先服务器会颁发一个公钥放在网络中，同时它自己还有一份私钥，然后客户端可以直接获取到对应的公钥</p> <p>然后将客户端的数据进行公钥的加密，加密后传输的服务器中，服务器在进行私钥解密，得到最终的数据</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413102124070.png" alt="image-20200413102124070"></p> <p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性，但是和对称加密比起来，它非常慢，所以我们还是要用对称加密来传送消息，但是对称加密使用的密钥我们通过非对称加密的方式发送出去。这个结果就变成了：</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413102622594.png" alt="image-20200413102622594"></p> <p>但是我们需要注意的是，此时交换的两个公钥不一定正确，因为可能会被中间人截获，同时掉包</p> <p>例如：中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰。</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413102718466.png" alt="image-20200413102718466"></p> <p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413102738635.png" alt="image-20200413102738635"></p> <h3 id="证书机制"><a href="#证书机制" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/README?id=%E8%AF%81%E4%B9%A6%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">证书机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>这个时候我们需要做的就是从指定的机构出获取公钥，而不是任由其在网络传输</p> <ul><li>作为服务器端的小红，首先先把自己的公钥给证书颁发机构，向证书颁发机构申请证书</li> <li>证书颁发机构自己也有一堆公钥和私钥。机构利用自己的私钥来解密Key1，通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给服务端的小红。</li> <li>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</li> <li>小灰收到证书以后，要做的第一件事就是验证证书的真伪，需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，所以小灰只需要知道是哪个机构颁发的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</li></ul> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2_https%E5%92%8Chttp/images/image-20200413103251089.png" alt="image-20200413103251089"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/计算机网络/GET和POST的区别.html" class="prev">
        GET和POST的区别
      </a></span> <span class="next"><a href="/计算机网络/TCP和UDP.html">
        TCP和UDP
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e7c2969b.js" defer></script><script src="/assets/js/2.94d3dfac.js" defer></script><script src="/assets/js/30.be0b3d6d.js" defer></script>
  </body>
</html>

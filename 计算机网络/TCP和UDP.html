<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TCP和UDP | winden96</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="winden96 的学习记录">
    
    <link rel="preload" href="/assets/css/0.styles.4fd6cf0c.css" as="style"><link rel="preload" href="/assets/js/app.e7c2969b.js" as="script"><link rel="preload" href="/assets/js/2.94d3dfac.js" as="script"><link rel="preload" href="/assets/js/31.5c853594.js" as="script"><link rel="prefetch" href="/assets/js/10.27cdeca9.js"><link rel="prefetch" href="/assets/js/11.07a9d483.js"><link rel="prefetch" href="/assets/js/12.2505f188.js"><link rel="prefetch" href="/assets/js/13.0d8bcb67.js"><link rel="prefetch" href="/assets/js/14.a1698ea2.js"><link rel="prefetch" href="/assets/js/15.dce506f4.js"><link rel="prefetch" href="/assets/js/16.82ab8250.js"><link rel="prefetch" href="/assets/js/17.1fa3722a.js"><link rel="prefetch" href="/assets/js/18.129b810d.js"><link rel="prefetch" href="/assets/js/19.7531d5a3.js"><link rel="prefetch" href="/assets/js/20.2c5f040e.js"><link rel="prefetch" href="/assets/js/21.635435c4.js"><link rel="prefetch" href="/assets/js/22.a44576c7.js"><link rel="prefetch" href="/assets/js/23.32ee5f65.js"><link rel="prefetch" href="/assets/js/24.109d908c.js"><link rel="prefetch" href="/assets/js/25.9ebc3e07.js"><link rel="prefetch" href="/assets/js/26.643e2283.js"><link rel="prefetch" href="/assets/js/27.44aebb00.js"><link rel="prefetch" href="/assets/js/28.269bc50f.js"><link rel="prefetch" href="/assets/js/29.5ba9d11a.js"><link rel="prefetch" href="/assets/js/3.dc23a8fe.js"><link rel="prefetch" href="/assets/js/30.be0b3d6d.js"><link rel="prefetch" href="/assets/js/32.06dd5c8a.js"><link rel="prefetch" href="/assets/js/33.66017b72.js"><link rel="prefetch" href="/assets/js/4.76c25a36.js"><link rel="prefetch" href="/assets/js/5.313f4ba0.js"><link rel="prefetch" href="/assets/js/6.3db81792.js"><link rel="prefetch" href="/assets/js/7.2b7d8442.js"><link rel="prefetch" href="/assets/js/8.19d8ddaf.js"><link rel="prefetch" href="/assets/js/9.4cbab228.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4fd6cf0c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">winden96</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>My SQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Boot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Cloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>杂记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>消息中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机网络</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/计算机网络/GET和POST的区别.html" class="sidebar-link">GET和POST的区别</a></li><li><a href="/计算机网络/HTTP和HTTPS.html" class="sidebar-link">HTTP和HTTPS</a></li><li><a href="/计算机网络/TCP和UDP.html" aria-current="page" class="active sidebar-link">TCP和UDP</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/计算机网络/TCP和UDP.html#三次握手" class="sidebar-link">三次握手</a></li><li class="sidebar-sub-header"><a href="/计算机网络/TCP和UDP.html#四次挥手" class="sidebar-link">四次挥手</a></li><li class="sidebar-sub-header"><a href="/计算机网络/TCP和UDP.html#tcp粘包-拆包" class="sidebar-link">TCP粘包/拆包</a></li></ul></li><li><a href="/计算机网络/输入网址之后发生了什么.html" class="sidebar-link">输入网址之后发生了什么</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="osi七层网络结构-每层对应的有什么协议"><a href="#osi七层网络结构-每层对应的有什么协议" class="header-anchor">#</a> osi七层⽹络结构？每层对应的有什么协议？</h1> <table><thead><tr><th>OSI七层网络模型</th> <th>TCP/IP五层网络模型</th> <th>对应网络协议</th></tr></thead> <tbody><tr><td>应用层</td> <td>应用层</td> <td><strong>HTTP、FTP</strong>、<strong>SMTP、POP3、DNS(域名系统)</strong></td></tr> <tr><td>表示层</td> <td>应用层</td> <td>LPP（轻量级表示协议）、NBSSN（会话服务协议）</td></tr> <tr><td>会话层</td> <td>应用层</td> <td>SSL、TLS（安全协议）</td></tr> <tr><td>传输层</td> <td>传输层</td> <td><strong>TCP、UDP</strong></td></tr> <tr><td>网络层</td> <td>网络层</td> <td><strong>IP、ICMP</strong>（互联网控制信息协议）</td></tr> <tr><td>数据链路层</td> <td>数据链路层</td> <td><strong>PPTP(点对点隧道协议)、ARP</strong></td></tr> <tr><td>物理层</td> <td>物理层</td> <td>IEEE 802.1A、IEEE802.2到IEEE 802.11</td></tr></tbody></table> <p><strong>应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则， 包括 HTTP、SMTP、POP3</strong></p> <p><strong>传输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务，建立起端到端的通信。包括TCP、UDP</strong>。</p> <p><strong>网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p> <p><strong>数据链路层两台主机之间的数据传输，总是在一段一段的链路上传送的，</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，协议包括 ARP</p> <p><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。</p> <p><img src="https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assert/1.gif" alt=""></p> <h1 id="tcp-和-udp的区别"><a href="#tcp-和-udp的区别" class="header-anchor">#</a> TCP 和 UDP的区别？</h1> <ul><li><p>TCP是⾯向连接的，UDP是⽆连接的；</p></li> <li><p>TCP是可靠的，通过TCP连接传送的数据， ⽆差错，不丢失，不重复 ；UDP不可靠， 即不保证可靠交付</p></li> <li><p>TCP只⽀持点对点通信，UDP⽀持⼀对⼀、⼀对多、多对⼀、多对多</p></li> <li><p>TCP是⾯向字节流的，UDP是⾯向报⽂的</p></li> <li><p>TCP有拥塞控制机制。UDP没有，因此⽹络出现的拥塞不会使源主机的发送速率降低，这
对某些实时应⽤是很重要的，⽐如媒体通信，游戏；</p></li> <li><p>TCP⾸部开销（20字节）⽐UDP⾸部开销（8字节）要⼤</p></li> <li><p>UDP 的主机不需要维持复杂的连接状态表。</p></li></ul> <h1 id="tcp的可靠性是怎么保证的"><a href="#tcp的可靠性是怎么保证的" class="header-anchor">#</a> TCP的可靠性是怎么保证的？</h1> <p><strong>数据包校验</strong>： TCP 将保持它首部和数据的检验和。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p> <p><strong>重新排序</strong>：对失序数据包重新 排序 （TCP报⽂具有序列号）
<strong>丢弃重复数据</strong>：TCP 的接收端会丢弃重复的数据。
<strong>应答机制</strong>：接收⽅收到数据之后，会发送⼀个确认（通常延迟⼏分之⼀秒）；
<strong>超时重传</strong>：发送⽅发出数据之后，启动⼀个定时器，超时未收到接收⽅的确认，则重新发送这个报文段；
<strong>流量控制</strong>：通过滑动窗口，确保接收端能够接收发送⽅的数据⽽不会缓冲区溢出</p> <p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p> <p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p> <h1 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="header-anchor">#</a> 三次握手和四次挥手</h1> <h2 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>为什么需要握手：握手的作用就是为了同步一些信息，比如最大滑动窗口</p> <p>TCP：是一个可靠的连接，也就是客户端和服务器双方必须感知对方的存在，也就是需要经历一个建立连接的过程</p> <p>用三次握手建立TCP连接，连接有三个阶段</p> <ul><li>建立连接</li> <li>数据传输</li> <li>连接释放</li></ul> <p>连接的管理就是使连接的建立和释放都能正常地进行，连接阶段过程中要解决以下三个问题</p> <ul><li>要使每一方都能确知对方的存在</li> <li>要允许双方协商一些参数</li> <li>能够对运输实体分配资源</li></ul> <h3 id="说说tcp三次握手过程"><a href="#说说tcp三次握手过程" class="header-anchor">#</a> 说说TCP三次握手过程？</h3> <p>TCP建立连接的过程：被称为握手</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/images/image-20200412155010409.png" alt="image-20200412155010409"></p> <p><img src="https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assert/2.png" alt=""></p> <p>1.第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;</p> <p>2.第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;</p> <p>3.第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p> <h3 id="为什么是三次握手"><a href="#为什么是三次握手" class="header-anchor">#</a> 为什么是三次握手？</h3> <blockquote><p>四次握手</p></blockquote> <p>四次连接有点多余，第三次的时候，我们已经互相进行了连接确认</p> <p>但是因为我们无法保证百分百的可靠性</p> <blockquote><p>两次握手</p></blockquote> <p><strong>客户端知道服务器有接收 和 发送的能力，服务器不知道客户端有没有接收数据的能力</strong>，因为通过第一次握手，已经知道了客户端能够发送数据，但是能不能接收数据，还是不清楚，因此这个TCP连接是不可靠的。</p> <p>为什么不能两次握手就建立连接</p> <p>因为超时重传机制的存在</p> <p>但客户端发送第一次握手的时候，可能会经历网络拥塞，然后客户端会以为这个连接已经丢失，然后会重新发送一个请求连接的信息到服务器，这次发送的消息很快被服务器接受，然后服务器建立连接就开始建立连接。但是当第一次发送的请求经过一段时间的阻塞后，成功到达服务器，然后服务器又连接连接，而此时客户端是不会理会这次请求的建立，所以服务器一直在等待客户端数据的发送。</p> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/images/image-20200412162156748.png" alt="image-20200412162156748"></p> <h2 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/README?id=%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" target="_blank" rel="noopener noreferrer">四次挥手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>所谓的四次挥手，就是关闭TCP连接的过程，指的是断开一个TPC连接，需要客户端和服务端总共发送4个包，以确定双方连接的断开。</p> <p>主要目的：保证TCP连接的全双工连接</p> <h3 id="四次挥手示意图"><a href="#四次挥手示意图" class="header-anchor">#</a> <a href="http://moxi159753.gitee.io/learningnotes/#/./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/README?id=%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE" target="_blank" rel="noopener noreferrer">四次挥手示意图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p><img src="http://moxi159753.gitee.io/learningnotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1_%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/images/20181120162254477.png" alt="img"></p> <p>由于TCP连接是全双工的，因此每个方向都必须单独关闭，这个原则是当以防完成它的数据发送任务后，就能发送一个FIN包来终止这个方向的连接。</p> <p>收到一个FIN包只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后，仍然能发送数据，首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p> <h3 id="说说四次挥手过程"><a href="#说说四次挥手过程" class="header-anchor">#</a> 说说四次挥手过程？</h3> <p><img src="https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assert/3.png" alt=""></p> <ul><li><strong>第一次挥手</strong>：客户端发送一个FIN包（FIN=1，seq=U）给服务器，用来关闭客户端到服务器端的数据传输，客户端进入FIN_WAIT_1状态（终止等待）</li> <li><strong>第二次挥手</strong>：服务器端收到FIN包后，发送一个ACK包（ACK=1，ack=u+1，在随机产生一个值v 给seq）给客户端，服务器进入了CLOSE_WAIT状态（关闭等待）</li> <li><strong>第三次挥手</strong>：服务器端发送一个FIN包（FIN=1，ACK=1，ack=u+1，在随机产生 一个w值给seq）给客户端，用来关闭服务器到客户端的数据传输，服务端进入了LAST_ACK（最后确定）状态</li> <li><strong>第四次挥手</strong>：客户端接收FIN包，然后进入TIME_WAIT状态，接着发送一个ACK包（ACK=1，seq=u+1, ack = w+1） 给服务端，服务端确定序号，进入CLOSe状态，完成了四次挥手。</li></ul> <h3 id="挥手中的状态"><a href="#挥手中的状态" class="header-anchor">#</a> 挥手中的状态</h3> <ul><li>CLOSED：表示初始状态</li> <li>ESTABLISHED：表示连接已经连接</li> <li>FIN_WAIT：状态FIN_WAIT_1和FIN_WAIT_2都表示等待对方的FIN报文，这两个状态的区别是，当主动发送方给对方发送了断开请求时，就进入了FIN_WAIT_1状态，而到被动方在回应后，主动发送方就进入了FIN_WAIT_2。</li> <li><strong>FIN_WAIT_2</strong>：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接</li> <li>CLOSE_WAIT：这个状态的含义是 表示在等待关闭</li> <li>LAST_ACK：在被动关闭放发送FIN报文后，最后等待对方的ACK报文，当收到了ACK报文后，就进入了CLOSE状态。</li></ul> <h3 id="为什么time-wait状态还需要等待2msl后才能返回close"><a href="#为什么time-wait状态还需要等待2msl后才能返回close" class="header-anchor">#</a> 为什么TIME_WAIT状态还需要等待2MSL后才能返回CLOSE</h3> <p>这是因为虽然双方都同意了关闭连接，而且握手的4个报文也都协调和发送完毕，按道理可以直接回到CLOSE状态</p> <p>但是因为我们需要假设网络是不可靠的，你无法保证你最后发送的ACK报文是会一定被对方收到，因此处于LAST_ACK状态下的socket可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的报文。</p> <h1 id="tcp-粘包-拆包问题"><a href="#tcp-粘包-拆包问题" class="header-anchor">#</a> TCP 粘包 拆包问题？</h1> <h2 id="tcp粘包-拆包"><a href="#tcp粘包-拆包" class="header-anchor">#</a> TCP粘包/拆包</h2> <p>TCP是个“流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。</p> <h3 id="tcp粘包-拆包问题说明"><a href="#tcp粘包-拆包问题说明" class="header-anchor">#</a> TCP粘包/拆包问题说明</h3> <p><img src="https://images2015.cnblogs.com/blog/990532/201612/990532-20161212192914995-1758321651.png" alt="img"></p> <p>假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。</p> <p>（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；</p> <p>（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；</p> <p>（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；</p> <p>（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</p> <p>如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第五种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。</p> <h3 id="tcp粘包-拆包发生的原因"><a href="#tcp粘包-拆包发生的原因" class="header-anchor">#</a> TCP粘包/拆包发生的原因</h3> <p>问题产生的原因有三个，分别如下。</p> <p>（1）应用程序write写入的字节大小大于套接口发送缓冲区大小；</p> <p>（2）进行MSS大小的TCP分段；</p> <p>（3）以太网帧的payload大于MTU进行IP分片。</p> <p><img src="https://images2015.cnblogs.com/blog/990532/201612/990532-20161212193751011-992309759.png" alt="img"></p> <h3 id="粘包问题的解决策略"><a href="#粘包问题的解决策略" class="header-anchor">#</a> 粘包问题的解决策略</h3> <p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。</p> <p>（1）消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；</p> <p>（2）在包尾增加回车换行符进行分割，例如FTP协议；</p> <p>（3）将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；</p> <p>（4）更复杂的应用层协议。</p> <p>但是一旦压力上来，或者发送大报文之后，就会存在粘包/拆包问题。如果代码没有考虑，往往就会出现解码错位或者错误，导致程序不能正常工作</p> <p>ps：上述其实可以 是 HTTP 的 header 记录一个 数据包的长度即可，动态调整</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/计算机网络/HTTP和HTTPS.html" class="prev">
        HTTP和HTTPS
      </a></span> <span class="next"><a href="/计算机网络/输入网址之后发生了什么.html">
        输入网址之后发生了什么
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e7c2969b.js" defer></script><script src="/assets/js/2.94d3dfac.js" defer></script><script src="/assets/js/31.5c853594.js" defer></script>
  </body>
</html>

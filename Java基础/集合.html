<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java中的集合 | winden96</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="winden96 的学习记录">
    
    <link rel="preload" href="/assets/css/0.styles.4fd6cf0c.css" as="style"><link rel="preload" href="/assets/js/app.e7c2969b.js" as="script"><link rel="preload" href="/assets/js/2.94d3dfac.js" as="script"><link rel="preload" href="/assets/js/12.2505f188.js" as="script"><link rel="prefetch" href="/assets/js/10.27cdeca9.js"><link rel="prefetch" href="/assets/js/11.07a9d483.js"><link rel="prefetch" href="/assets/js/13.0d8bcb67.js"><link rel="prefetch" href="/assets/js/14.a1698ea2.js"><link rel="prefetch" href="/assets/js/15.dce506f4.js"><link rel="prefetch" href="/assets/js/16.82ab8250.js"><link rel="prefetch" href="/assets/js/17.1fa3722a.js"><link rel="prefetch" href="/assets/js/18.129b810d.js"><link rel="prefetch" href="/assets/js/19.7531d5a3.js"><link rel="prefetch" href="/assets/js/20.2c5f040e.js"><link rel="prefetch" href="/assets/js/21.635435c4.js"><link rel="prefetch" href="/assets/js/22.a44576c7.js"><link rel="prefetch" href="/assets/js/23.32ee5f65.js"><link rel="prefetch" href="/assets/js/24.109d908c.js"><link rel="prefetch" href="/assets/js/25.9ebc3e07.js"><link rel="prefetch" href="/assets/js/26.643e2283.js"><link rel="prefetch" href="/assets/js/27.44aebb00.js"><link rel="prefetch" href="/assets/js/28.269bc50f.js"><link rel="prefetch" href="/assets/js/29.5ba9d11a.js"><link rel="prefetch" href="/assets/js/3.dc23a8fe.js"><link rel="prefetch" href="/assets/js/30.be0b3d6d.js"><link rel="prefetch" href="/assets/js/31.5c853594.js"><link rel="prefetch" href="/assets/js/32.06dd5c8a.js"><link rel="prefetch" href="/assets/js/33.66017b72.js"><link rel="prefetch" href="/assets/js/4.76c25a36.js"><link rel="prefetch" href="/assets/js/5.313f4ba0.js"><link rel="prefetch" href="/assets/js/6.3db81792.js"><link rel="prefetch" href="/assets/js/7.2b7d8442.js"><link rel="prefetch" href="/assets/js/8.19d8ddaf.js"><link rel="prefetch" href="/assets/js/9.4cbab228.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4fd6cf0c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">winden96</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JUC</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JVM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Java基础/Java8新特性.html" class="sidebar-link">详解JDK8新特性</a></li><li><a href="/Java基础/泛型.html" class="sidebar-link">Java泛型</a></li><li><a href="/Java基础/集合.html" aria-current="page" class="active sidebar-link">Java中的集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_2-1-hashmap" class="sidebar-link">2.1 HashMap</a></li><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_2-2-treemap" class="sidebar-link">2.2 TreeMap</a></li><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_2-3-hashtable" class="sidebar-link">2.3 HashTable</a></li><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_2-4-concurrenthashmap" class="sidebar-link">2.4 ConCurrentHashMap</a></li><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_3-1-list" class="sidebar-link">3.1 List</a></li><li class="sidebar-sub-header"><a href="/Java基础/集合.html#_3-2-set" class="sidebar-link">3.2 Set</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>My SQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Mybatis Plus</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Boot</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring Cloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>杂记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>消息中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_1-集合的常见关系图"><a href="#_1-集合的常见关系图" class="header-anchor">#</a> 1. 集合的常见关系图</h1> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C4.png" alt=""></p> <p>更正：为LinkedHashMap， Map还有个 HashTable</p> <h1 id="_2-map"><a href="#_2-map" class="header-anchor">#</a> 2. Map</h1> <h2 id="_2-1-hashmap"><a href="#_2-1-hashmap" class="header-anchor">#</a> 2.1 HashMap</h2> <h3 id="_2-1-1-hashmap-是怎么实现的"><a href="#_2-1-1-hashmap-是怎么实现的" class="header-anchor">#</a> 2.1.1 HashMap 是怎么实现的</h3> <blockquote><p>HashMap怎么实现的?</p></blockquote> <p>1、HashMap底层是用数组+双向链表+红黑树实现的</p> <p>2、插入元素的时候，首先通过一个hash方法计算得到key的哈希值，进而计算出待插入的位置</p> <p>3、如果该位置为空，则直接插入（包装成Node）</p> <p>4、如果该位置有值，则依次遍历。比较的规则是，hash值相同，key值相等的元素视为相同，则用新值替换旧值并返回旧值。</p> <p>5、如果该位置的元素是红黑树结构，则同理，查找，找到则替换，没找到则插入。</p> <p>初始容量为<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（16），负载因子为 <code>0.75</code></p> <blockquote><p>为什么设置初始容量为16？</p></blockquote> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><p>对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。</p> <p>因为 假如是 2的幂减1求出来的二进制都是1111，求 &amp; 运算方便，从而能够快速的拿到下标，并且也是相当于对 <code>length</code> 取模了，保证了散列的均匀</p> <p>而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间。所以，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</p> <blockquote><p>为什么负载因子设置为 0.75</p></blockquote> <p>默认的负载因子(.75)提供了一个好的时间和空间成本之间的权衡。较高的值降低空间开销，但增加了查找成本(反映在大多数HashMap类的操作，包括get and put)。主要是泊松分布，如果是 0.75 碰撞最小</p> <p>当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。</p> <p>加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；</p> <p><strong>加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数</strong>。</p> <p><strong>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。</strong></p> <p><strong>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择，</strong></p> <h3 id="_2-1-2-插入元素"><a href="#_2-1-2-插入元素" class="header-anchor">#</a> 2.1.2 插入元素</h3> <p>参照了博客：https://www.cnblogs.com/cjsblog/p/8207211.html</p> <p>首先 HashMap 是在第一次执行插入的时候进行初始化</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C2.png" alt=""></p> <p>数组arr[i]处的链表转为红黑树的条件，其他位置如 arr[i+1] 处的数组元素仍为链表，不受影响</p> <ul><li>数组arr[i] 处存放的链表长度大于8</li> <li>数组长度大于64</li></ul> <p>转化成红黑树调用<code>treeifyBin</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                    tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>如果table长度小于常量<code>MIN_TREEIFY_CAPACITY</code>时，不会变为红黑树，而是调用resize()方法进行扩容。<code>MIN_TREEIFY_CAPACITY</code>的默认值是64。显然HashMap认为，虽然链表长度超过了8，但是table长度太短，只需要扩容然后重新散列一下就可以。</p> <p>后面的代码中可以看到，如果table长度已经达到了64，就会开始变为红黑树，else if中的代码把原来的Node节点变成了TreeNode节点，并且进行了红黑树的转换。</p> <p>1、如果数组还没有初始化（数组长度是0），则先初始化</p> <p>2、通过hash方法计算key的hash值，进而计算得到应该放置到数组的位置</p> <p>3、如果该位置为空，则直接放置此处</p> <p>4、如果该位置不为空，而且元素是红黑树，则插入到其中</p> <p>5、如果是链表，则遍历链表，如果找到相等的元素则替换，否则插入到链表尾部</p> <p>6、如果链表的长度大于或等于8，则将链表转成红黑树</p> <ol><li>如果能够找到该key的结点，则执行更新操作。</li> <li>如果没有找到该key的结点，则执行插入操作，需要对modCount++。</li> <li>在执行插入操作之后，如果size超过了threshold，这要扩容执行resize()。</li></ol> <p>第一步：key.hashcode()，时间复杂度O(1)。</p> <p>第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entey节点插入到数组中。时间复杂度O(1)。</p> <p>第三步：如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。</p> <blockquote><p>桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</p></blockquote> <p>第四步：如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是logn。</p> <blockquote><p>补充：红黑树</p></blockquote> <p>红黑树是一种近似平衡的二叉查找树，他并非绝对平衡，但是可以保证任何一个节点的左右子树的高度差不会超过二者中较低的那个的一倍。</p> <p>红黑树有这样的特点：</p> <p>1，每个节点要么是红色，要么是黑色。</p> <p>2，根节点必须是黑色。叶子节点必须是黑色NULL节点。</p> <p>3，红色节点不能连续。</p> <p>4，对于每个节点，从该点至叶子节点的任何路径，都含有相同个数的黑色节点。</p> <p>5，能够以O(log2(N))的时间复杂度进行搜索、插入、删除操作。此外,任何不平衡都会在3次旋转之内解决。</p> <h3 id="_2-1-3-如何获取元素"><a href="#_2-1-3-如何获取元素" class="header-anchor">#</a> 2.1.3 如何获取元素</h3> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C3.png" alt=""></p> <p>1、计算hash求位置</p> <p>2、看第一个元素是不是要找的，是则返回，否则遍历</p> <p>时间复杂度</p> <ul><li>在理想状态下，及未发生任何hash碰撞，数组中的每一个链表都只有一个节点，那么get方法可以通过hash直接定位到目标元素在数组中的位置，时间复杂度为O(1)。</li> <li>若发生hash碰撞，则可能需要进行遍历寻找，n个元素的情况下，链表时间复杂度为O(n)、红黑树为O(logn)</li></ul> <h3 id="_2-1-4-hashmap的扩容机制是怎么实现的"><a href="#_2-1-4-hashmap的扩容机制是怎么实现的" class="header-anchor">#</a> 2.1.4 HashMap的扩容机制是怎么实现的</h3> <p>参考：https://blog.csdn.net/lkforce/article/details/89521318</p> <p>https://codeantenna.com/a/7dRK8CU96c</p> <p>当元素数目大于table容量大小 * 负载因子的值时，执行扩容</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>
       <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
       <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
       <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 超过最大不再扩充</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
               <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token comment">// 在resize()方法中，定义了oldCap参数，记录了原table的长度，定义了newCap参数，记录新table长度，newCap是oldCap长度的2倍（注释1），同时扩展点也乘2。</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
                    oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
               newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
           newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
       <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>
           newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
           newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
      	<span class="token comment">// 计算新的resize上限</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
           newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
                     <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
       <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>
       table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>
  
       <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 循环原table，把原table中的每个链表中的每个元素放入新table</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                       <span class="token comment">// e.next==null，指的是链表中只有一个元素，所以直接把e放入新table，其中的e.hash &amp; (newCap - 1)就是计算e在新table中的位置，和JDK1.7中的indexFor()方法是一回事</span>
                       newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
                   <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                       <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>
                       <span class="token comment">// 链表优化重hash</span>
                       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
                       <span class="token keyword">do</span> <span class="token punctuation">{</span>
                           next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                           <span class="token comment">// e.hash &amp; oldCap，就是用于计算位置b到底是0还是1用的，只要其结果是0，则新散列下标就等于原散列下标，否则新散列坐标要在原散列坐标的基础上加上原table长度</span>
                           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                   loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                               <span class="token keyword">else</span>
                                   loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                               loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                           <span class="token keyword">else</span> <span class="token punctuation">{</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                   hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
                               <span class="token keyword">else</span>
                                   hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
                               hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                       <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                           newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
                       <span class="token punctuation">}</span>
                       <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                           newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
                       <span class="token punctuation">}</span>
                   <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-1-5-重写equals的时候为什么要重写hashcode"><a href="#_2-1-5-重写equals的时候为什么要重写hashcode" class="header-anchor">#</a> 2.1.5 重写Equals的时候为什么要重写HashCode</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> idCard<span class="token punctuation">;</span>
        <span class="token class-name">String</span> name<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idCard<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>idCard <span class="token operator">=</span> idCard<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
            <span class="token comment">//两个对象是否等值，通过idCard来确定</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>idCard <span class="token operator">==</span> person<span class="token punctuation">.</span>idCard<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">,</span><span class="token string">&quot;乔峰&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//put到hashmap中去</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span><span class="token string">&quot;天龙八部&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//get取出，从逻辑上讲应该能输出“天龙八部”</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;结果:&quot;</span><span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">,</span><span class="token string">&quot;萧峰&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果</p> <div class="language-java extra-class"><pre class="language-java"><code>结果<span class="token operator">:</span><span class="token keyword">null</span>
</code></pre></div><p>我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)--&gt;hash--&gt;indexFor--&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p> <p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p> <h3 id="_2-1-6-linkedhashmap-是什么-有什么用"><a href="#_2-1-6-linkedhashmap-是什么-有什么用" class="header-anchor">#</a> 2.1.6 LinkedHashMap 是什么，有什么用</h3> <p>LinkedHashMap底层数据结构是数组+链表/红黑树+双向链表</p> <p>https://blog.csdn.net/justloveyou_/article/details/71713781</p> <p>将所有桶中的节点串联成一个双向链表  适合建立LRU缓存，允许空元素</p> <h2 id="_2-2-treemap"><a href="#_2-2-treemap" class="header-anchor">#</a> 2.2 TreeMap</h2> <p>https://blog.csdn.net/qq_32166627/article/details/72773293</p> <p>TreeMap集合是基于 <strong>红黑树</strong>（Red-Black tree）的 NavigableMap实现。该集合最重要的特点就是<strong>可排序</strong> ，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。这句话是什么意思呢？就是说TreeMap可以对添加进来的元素进行排序，可以按照默认的排序方式，也可以自己指定排序方式。</p> <p>根据上一条，我们要想使用TreeMap存储并排序我们自定义的类（如User类），那么必须自己定义比较机制：一种方式是User类去实现java.lang.Comparable接口，并实现其compareTo()方法。另一种方式是写一个类（如MyCompatator）去实现java.util.Comparator接口，并实现compare()方法，然后将MyCompatator类实例对象作为TreeMap的构造方法参数进行传参（当然也可以使用匿名内部类），这些比较方法是怎么被调用的将在源码中讲解。</p> <h2 id="_2-3-hashtable"><a href="#_2-3-hashtable" class="header-anchor">#</a> 2.3 HashTable</h2> <p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下（它的实现就是将put、get、size等方法加上 synchronized 关键字）。使用 CurrentHashMap 效率比较高</p> <blockquote><p>HashMap 和 HashTable 对比</p></blockquote> <p>（1）线程安全：HashMap是线程不安全的类，多线程下会造成并发冲突，但单线程下运行效率较高；HashTable是线程安全的类，很多方法都是用synchronized修饰，但同时因为加锁导致并发效率低下，单线程环境效率也十分低；</p> <p>（2）插入null：HashMap允许有一个键为null，允许多个值为null；<strong>但HashTable不允许键或值为null；</strong></p> <p>（3）容量：HashMap底层数组长度必须为2的幂，这样做是为了hash准备，默认为16；而HashTable底层数组长度可以为任意值，这就造成了hash算法散射不均匀，容易造成hash冲突，默认为11；</p> <p>（4）Hash映射：HashMap的hash算法通过非常规设计，将底层table长度设计为2的幂，使用位与运算代替取模运算，减少运算消耗；而HashTable的hash算法首先使得hash值小于整型数最大值，再通过取模进行散射运算；</p> <p>（5）扩容机制：HashMap创建一个为原先2倍的数组，然后对原数组进行遍历以及rehash；HashTable扩容将创建一个原长度2倍的数组，再使用头插法将链表进行反序；</p> <p>（6）结构区别：HashMap是由数组+链表形成，在JDK1.8之后链表长度大于8时转化为红黑树；而HashTable一直都是数组+链表；</p> <p>（7）继承关系：HashTable继承自Dictionary类；而HashMap继承自AbstractMap类；</p> <p>（8）迭代器：HashMap是fail-fast（查看之前HashMap相关文章）；而HashTable不是。</p> <h2 id="_2-4-concurrenthashmap"><a href="#_2-4-concurrenthashmap" class="header-anchor">#</a> 2.4 ConCurrentHashMap</h2> <h3 id="_2-4-1-concurrenthashmap-是什么-如何保障安全"><a href="#_2-4-1-concurrenthashmap-是什么-如何保障安全" class="header-anchor">#</a> 2.4.1 ConCurrentHashMap 是什么，如何保障安全</h3> <p>ConcurrentHashMap的底层数据结构是数组+链表/红黑树，它能支持高并发的访问和更新，是线程安全的。</p> <p>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。</p> <p>在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁</p> <p>https://blog.csdn.net/weixin_39611722/article/details/110611702</p> <ul><li>数据存储利用 volatile 来保证可见性。</li> <li>使用 CAS 等操作，在特定场景进行无锁并发操作。</li></ul> <h1 id="_3-collection"><a href="#_3-collection" class="header-anchor">#</a> 3. Collection</h1> <h2 id="_3-1-list"><a href="#_3-1-list" class="header-anchor">#</a> 3.1 List</h2> <h3 id="_3-1-1-arraylist"><a href="#_3-1-1-arraylist" class="header-anchor">#</a> 3.1.1 ArrayList</h3> <p>参考：https://veal98.gitee.io/cs-wiki/#/Java/%E9%9B%86%E5%90%88</p> <h4 id="_3-1-1-1-arraylist-是啥-有啥用"><a href="#_3-1-1-1-arraylist-是啥-有啥用" class="header-anchor">#</a> 3.1.1.1 ArrayList 是啥，有啥用?</h4> <p><code>ArrayList</code> 就实现了 <code>List</code> 接口，其实就是一个数组列表，不过作为 Java 的集合框架，它只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 <code>int</code>、<code>float</code> 等基本数据类型的时候，必须把它们转换成对应的包装类。</p> <p><code>ArrayList</code> 的底层实现是一个 <code>Object</code> 数组：</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C5.png" alt=""></p> <p>因为是数组，所以查找快，增删慢。而<code>LinkedList</code> 为一个双向链表，增删快，查找慢</p> <h4 id="_3-1-1-2-arraylist-数组初始化如何进行的"><a href="#_3-1-1-2-arraylist-数组初始化如何进行的" class="header-anchor">#</a> 3.1.1.2 ArrayList 数组初始化如何进行的</h4> <p>初始化会初始化为一个空数组</p> <img src="D:\java练习\面试\准备的面试\assert\6.png" style="zoom:50%;"> <p>当只有在 <code>add</code> 操作的时候才会进行对数组分配初始容量，<code>DEFAULT_CAPACITY = 10</code></p> <img src="D:\java练习\面试\准备的面试\assert\8.png" style="zoom:67%;"> <p>有参构造函数，通过输入指定的容量进行初始化为指定容量大小</p> <img src="D:\java练习\面试\准备的面试\assert\9.png" style="zoom:67%;"> <h4 id="_3-1-1-3-arraylist-的扩容机制是如何实现的"><a href="#_3-1-1-3-arraylist-的扩容机制是如何实现的" class="header-anchor">#</a> 3.1.1.3 ArrayList 的扩容机制是如何实现的？</h4> <p>在 <code>add</code> 时，通过 <code>ensureCapacityInternal</code> 判断是否需要扩容</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C10.png" alt=""></p> <p>通过</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C11.png" alt=""></p> <img src="D:\java练习\面试\准备的面试\assert\13.png" style="zoom:80%;"> <p>通过加大长度，然后使用 <code>Arrays.copyOf</code> 把原数组中的数组 copy 过来，通过创建一个新的数组进行拷贝</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C14.png" alt=""></p> <h4 id="_3-1-1-4-如何进行添加元素的"><a href="#_3-1-1-4-如何进行添加元素的" class="header-anchor">#</a> 3.1.1.4 如何进行添加元素的？</h4> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C15.png" alt=""></p> <p>先讲下 <code>add(int index, E element)</code> 这个方法的含义，就是在指定索引 index 处插入元素 element。比如说 <code>ArrayList.add(0, 3)</code>，意思就是在头部插入元素 3。</p> <p>再来看看 <code>add</code> 方法的核心 <code>System.arraycopy</code>，这个方法有 5 个参数：</p> <ul><li>elementData：源数组</li> <li>index：从源数组中的哪个位置开始复制</li> <li>elementData：目标数组</li> <li>index + 1：复制到目标数组中的哪个位置</li> <li>size - index：要复制的源数组中数组元素的数量</li></ul> <p>解释一下上面代码中 <code>arraycopy</code> 的意思，举个例子，我们想要在 index = 5 的位置插入元素，首先，我们会复制一遍源数组 elementData（这里我们称复制的数组为新数组吧），然后把源数组中从 index = 5 的位置开始到数组末尾的元素，放到新数组的 index + 1 = 6 的位置上：</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C16.png" alt=""></p> <p>于是，这就给我们要新增的元素腾出了位置，然后在新数组 index = 5 的位置放入元素 element 就完成了添加的操作：</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C17.png" alt=""></p> <p>不用多说，ArrayList 的将数据插入到指定位置的操作性能非常低下，因为要开辟新数组复制元素啊，要是涉及到扩容那就更慢了。</p> <p>另外，<code>ArrayList</code> 还内置了一个直接在末尾添加元素的 <code>add</code> 方法，不用复制数组，直接 size ++ 就好，这个方法应该是我们最常使用的：直接添加元素到末尾</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C18.png" alt=""></p> <h4 id="_3-1-1-5-arraylist-如何删除元素的"><a href="#_3-1-1-5-arraylist-如何删除元素的" class="header-anchor">#</a> 3.1.1.5 ArrayList 如何删除元素的？</h4> <img src="D:\java练习\面试\准备的面试\assert\19.png" style="zoom:80%;"> <p>举个例子，假设我们要删除数组的 index = 5 的元素，首先，我们会复制一遍源数组，然后把源数组中从 index + 1 = 6 的位置开始到数组末尾的元素，放到新数组的 index = 5 的位置上：</p> <p><img src="D:%5Cjava%E7%BB%83%E4%B9%A0%5C%E9%9D%A2%E8%AF%95%5C%E5%87%86%E5%A4%87%E7%9A%84%E9%9D%A2%E8%AF%95%5Cassert%5C20.png" alt=""></p> <p>也就是说 index = 5 的元素直接被覆盖掉了，给了你被删除的感觉。同样的，它的效率自然也是十分低下的</p> <h4 id="_3-1-1-6-arraylist为什么不安全"><a href="#_3-1-1-6-arraylist为什么不安全" class="header-anchor">#</a> 3.1.1.6 ArrayList为什么不安全？</h4> <p>因为在 比如 <code>add</code> 操作时，<code>elementData[size++]=e</code> 非原子操作</p> <img src="D:\java练习\面试\准备的面试\assert\21.png" style="zoom:67%;"> <p>等价于</p> <div class="language-java extra-class"><pre class="language-java"><code>elementData<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
size <span class="token operator">=</span> size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生<strong>一个线程添加的值覆盖另一个线程添加的值</strong>。举个例子：</p> <ul><li>假设 size = 0，我们要往这个数组的末尾添加元素</li> <li>线程 A 开始添加一个元素，值为 A。此时它执行第一条操作，将 A 放在了数组 elementData 下标为 0 的位置上</li> <li>接着线程 B 刚好也要开始添加一个值为 B 的元素，且走到了第一步操作。此时线程 B 获取到的 size 值依然为 0，于是它将 B 也放在了 elementData 下标为 0 的位置上</li> <li>线程 A 开始增加 size 的值，size = 1</li> <li>线程 B 开始增加 size 的值，size = 2</li></ul> <p>这样，线程 A、B 都执行完毕后，理想的情况应该是 size = 2，elementData[0] = A，elementData[1] = B。而实际情况变成了 size = 2，elementData[0] = B（线程 B 覆盖了线程 A 的操作），下标 1 的位置上什么都没有。并且后续除非我们使用 set 方法修改下标为 1 的值，否则这个位置上将一直为 null，因为在末尾添加元素时将会从 size = 2 的位置上开始。</p> <div class="language-java extra-class"><pre class="language-java"><code>  <span class="token comment">// 验证添加操作不安全</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 0-10添加到 list 中</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 将 10- 20 添加到列表中</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;第 &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 个元素为 &quot;</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><img src="D:\java练习\面试\准备的面试\assert\22.png" style="zoom:67%;"> <h4 id="_3-1-1-7-为什么还要使用-arraylist"><a href="#_3-1-1-7-为什么还要使用-arraylist" class="header-anchor">#</a> 3.1.1.7 为什么还要使用 ArrayList?</h4> <p>因为在大多数场景中，查询的情况居多，不会涉及太频繁的增删。那如果真的涉及频繁的增删，可以使用<code>LinkedList</code>，底层链表实现，为增删而生。而如果你非得保证线程安全那就使用 <code>Vector</code>。当然实际开发中使用最多的还是 <code>ArrayList</code>，虽然线程不安全、增删效率低，但是查询效率高啊。</p> <p>但是现在 ArrayList 的增删底层调用的 <code>arraycopy</code> 被优化过，现在 CPU 对内存可以块操作，ArrayList 的增删不会比 LinkList 慢</p> <h4 id="_3-1-1-8-vector了解吗"><a href="#_3-1-1-8-vector了解吗" class="header-anchor">#</a> 3.1.1.8 Vector了解吗？</h4> <p>Vector是底层结构是数组，相对于ArrayList，它是线程安全的，把所有的方法统统加上 <code>synchronized</code>， 并且在扩容的时候它是直接扩容两倍的。因为太慢了，逐渐被淘汰</p> <h4 id="_3-1-1-9-线程安全的-list-还有哪些呢"><a href="#_3-1-1-9-线程安全的-list-还有哪些呢" class="header-anchor">#</a> 3.1.1.9 线程安全的 list 还有哪些呢？</h4> <p>首先可以使用 Collections来将ArrayList来包装一下，变成线程安全</p> <p>其次：在java.util.concurrent包下还有一个类，叫做CopyOnWriteArrayList</p> <blockquote><p>CopyOnWriteArrayList</p></blockquote> <p>copy-on-write可以理解为我们的懒加载，或者说单例模式的懒汉式。等真正用到的时候再分配,底层是通过复制数组的方式来实现的。</p> <p>在add()方法其实他会加lock锁，然后会复制出一个新的数组，往新的数组里边add真正的元素，最后把array的指向改变为新的数组</p> <p>get()方法又或是size()方法只是获取array所指向的数组的元素或者大小。读不加锁，写加锁</p> <p>CopyOnWriteArrayList是很耗费内存的，每次set()/add()都会复制一个数组出来</p> <p>CopyOnWriteArrayList只能保证数据的最终一致性，不能保证数据的实时一致性。</p> <p>假设两个线程，线程A去读取CopyOnWriteArrayList的数据，还没读完，现在线程B把这个List给清空了，线程A此时还是可以把剩余的数据给读出来。</p> <h3 id="_3-1-2-linkedlist"><a href="#_3-1-2-linkedlist" class="header-anchor">#</a> 3.1.2 LinkedList</h3> <h4 id="_3-1-2-1-linkedlist-是什么-与arraylist-有什么区别"><a href="#_3-1-2-1-linkedlist-是什么-与arraylist-有什么区别" class="header-anchor">#</a> 3.1.2.1 LinkedList 是什么，与ArrayList 有什么区别？</h4> <p>LinkedList的实现较为简单：底层使用双向链表实现、保留了头尾两个指针，增删比较快，查找比较慢</p> <p>ArrayList：底层是Object数组实现的：由于数组的地址是连续的，数组支持O(1)随机访问；数组在初始化时需要指定容量；数组不支持动态扩容，像ArrayList、Vector和Stack使用的时候看似不用考虑容量问题（因为可以一直往里面存放数据）；但是它们的底层实际做了扩容；数组扩容代价比较大，需要开辟一个新数组将数据拷贝进去，数组扩容效率低；适合读数据较多的场合
LinkedList：底层使用一个Node数据结构，有前后两个指针，双向链表实现的。相对数组，链表插入效率较高，只需要更改前后两个指针即可；另外链表不存在扩容问题，因为链表不要求存储空间连续，每次插入数据都只是改变last指针；另外，链表所需要的内存比数组要多，因为他要维护前后两个指针；它适合删除，插入较多的场景。另外，LinkedList还实现了Deque接口。</p> <h2 id="_3-2-set"><a href="#_3-2-set" class="header-anchor">#</a> 3.2 Set</h2> <h3 id="_3-2-1-hashset-是什么"><a href="#_3-2-1-hashset-是什么" class="header-anchor">#</a> 3.2.1 HashSet 是什么？</h3> <p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p> <p>HashSet 允许有 null 值。</p> <p>HashSet 是无序的，即不会记录插入的顺序。</p> <p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p> <h4 id="_3-2-1-1-treeset-是什么"><a href="#_3-2-1-1-treeset-是什么" class="header-anchor">#</a> 3.2.1.1 TreeSet 是什么？</h4> <p>TreeSet 是根据 TreeMap 实现的</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Java基础/泛型.html" class="prev">
        Java泛型
      </a></span> <span class="next"><a href="/Linux/linux.html">
        Linux的学习
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e7c2969b.js" defer></script><script src="/assets/js/2.94d3dfac.js" defer></script><script src="/assets/js/12.2505f188.js" defer></script>
  </body>
</html>

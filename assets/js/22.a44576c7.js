(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{423:function(_,v,t){"use strict";t.r(v);var s=t(56),e=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"进程和线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[_._v("#")]),_._v(" 进程和线程")]),_._v(" "),t("blockquote",[t("p",[_._v("参考：http://learn.lianglianglee.com/")])]),_._v(" "),t("h2",{attrs:{id:"操作系统中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作系统中"}},[_._v("#")]),_._v(" 操作系统中")]),_._v(" "),t("h4",{attrs:{id:"进程和线程-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程-2"}},[_._v("#")]),_._v(" 进程和线程")]),_._v(" "),t("p",[_._v("进程（Process），顾名思义就是正在执行的应用程序，是软件的执行副本。而线程是轻量级的进程。")]),_._v(" "),t("p",[_._v("进程是分配资源的基础单位。而线程很长一段时间被称作轻量级进程（Light Weighted Process），是程序执行的基本单位。")]),_._v(" "),t("p",[_._v("一个应用程序启动后会在内存中创建一个执行副本，这就是"),t("strong",[_._v("进程")]),_._v("。Linux 的内核是一个 Monolithic Kernel（宏内核），因此可以看作一个进程。也就是开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。")]),_._v(" "),t("ul",[t("li",[_._v("内核空间（Kernal Space），这个空间只有内核程序可以访问；")]),_._v(" "),t("li",[_._v("用户空间（User Space），这部分内存专门给应用程序使用。")])]),_._v(" "),t("p",[_._v("进程可以分成用户态进程和内核态进程两类。用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。")]),_._v(" "),t("p",[t("strong",[_._v("那么用户态进程如果要执行程序，是否也要向内核申请呢")]),_._v("？")]),_._v(" "),t("p",[_._v("程序在现代操作系统中并不是以进程为单位在执行，而是以一种轻量级进程（Light Weighted Process），也称作线程（Thread）的形式执行。")]),_._v(" "),t("p",[_._v("一个进程可以拥有多个线程。进程创建的时候，一般会有一个主线程随着进程创建而创建。")]),_._v(" "),t("p",[t("img",{attrs:{src:"http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/assets/Ciqc1F-SmgGAJVo6AAFL0OwiOWE251.png",alt:"2.png"}})]),_._v(" "),t("p",[_._v("如果进程想要创造更多的线程，就需要思考一件事情，这个线程创建在用户态还是内核态。")]),_._v(" "),t("p",[_._v("你可能会问，难道不是用户态的进程创建用户态的线程，内核态的进程创建内核态的线程吗？")]),_._v(" "),t("p",[_._v("其实不是，进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程，接下来我们说说用户态的线程和内核态的线程。")]),_._v(" "),t("h4",{attrs:{id:"用户态线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户态线程"}},[_._v("#")]),_._v(" 用户态线程")]),_._v(" "),t("p",[_._v("用户态线程也称作用户级线程（User Level Thread）。操作系统内核并不知道它的存在，它完全是在用户空间中创建。")]),_._v(" "),t("p",[_._v("用户级线程有很多优势，比如。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("管理开销小")]),_._v("：创建、销毁不需要系统调用。")]),_._v(" "),t("li",[t("strong",[_._v("切换成本低")]),_._v("：用户空间程序可以自己维护，不需要走操作系统调度。")])]),_._v(" "),t("p",[_._v("但是这种线程也有很多的缺点。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("与内核协作成本高")]),_._v("：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。")]),_._v(" "),t("li",[t("strong",[_._v("线程间协作成本高")]),_._v("：设想两个线程需要通信，通信需要 I/O，I/O 需要系统调用，因此用户态线程需要支付额外的系统调用成本。")]),_._v(" "),t("li",[t("strong",[_._v("无法利用多核优势")]),_._v("：比如操作系统调度的仍然是这个线程所属的进程，所以无论每次一个进程有多少用户态的线程，都只能并发执行一个线程，因此一个进程的多个线程无法利用多核的优势。")]),_._v(" "),t("li",[t("strong",[_._v("操作系统无法针对线程调度进行优化")]),_._v("：当一个进程的一个用户态线程阻塞（Block）了，操作系统无法及时发现和处理阻塞问题，它不会更换执行其他线程，从而造成资源浪费。")])]),_._v(" "),t("h4",{attrs:{id:"内核态线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内核态线程"}},[_._v("#")]),_._v(" 内核态线程")]),_._v(" "),t("p",[_._v("内核态线程也称作内核级线程（Kernel Level Thread）。这种线程执行在内核态，可以通过系统调用创造一个内核级线程。")]),_._v(" "),t("p",[_._v("内核级线程有很多优势。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("可以利用多核 CPU 优势")]),_._v("：内核拥有较高权限，因此可以在多个 CPU 核心上执行内核线程。")]),_._v(" "),t("li",[t("strong",[_._v("操作系统级优化")]),_._v("：内核中的线程操作 I/O 不需要进行系统调用；一个内核线程阻塞了，可以立即让另一个执行。")])]),_._v(" "),t("p",[_._v("当然内核线程也有一些缺点。")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("创建成本高")]),_._v("：创建的时候需要系统调用，也就是切换到内核态。")]),_._v(" "),t("li",[t("strong",[_._v("扩展性差")]),_._v("：由一个内核程序管理，不可能数量太多。")]),_._v(" "),t("li",[t("strong",[_._v("切换成本较高")]),_._v("：切换的时候，也同样存在需要内核操作，需要切换内核态。")])]),_._v(" "),t("p",[t("strong",[_._v("用户态线程和内核态线程的区别？")])]),_._v(" "),t("p",[_._v("老规矩，请你先在脑海里构思下给面试官的表述，并把你的思考写在留言区，然后再来看我接下来的分析。")]),_._v(" "),t("p",[t("strong",[_._v("【解析】")]),_._v(" 用户态线程工作在用户空间，内核态线程工作在内核空间。用户态线程调度完全由进程负责，通常就是由进程的主线程负责。相当于进程主线程的延展，使用的是操作系统分配给进程主线程的时间片段。内核线程由内核维护，由操作系统调度。")]),_._v(" "),t("p",[_._v("用户态线程无法跨核心，一个进程的多个用户态线程不能并发，阻塞一个用户态线程会导致进程的主线程阻塞，直接交出执行权限。这些都是用户态线程的劣势。内核线程可以独立执行，操作系统会分配时间片段。因此内核态线程更完整，也称作轻量级进程。内核态线程创建成本高，切换成本高，创建太多还会给调度算法增加压力，因此不会太多。")]),_._v(" "),t("p",[_._v("实际操作中，往往结合两者优势，将用户态线程附着在内核态线程中执行。")]),_._v(" "),t("h4",{attrs:{id:"进程和线程的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的状态"}},[_._v("#")]),_._v(" 进程和线程的状态")]),_._v(" "),t("p",[_._v("一个进程（线程）运行的过程，会经历以下 3 个状态：")]),_._v(" "),t("ul",[t("li",[_._v("进程（线程）创建后，就开始排队，此时它会处在“就绪”（Ready）状态；")]),_._v(" "),t("li",[_._v("当轮到该进程（线程）执行时，会变成“运行”（Running）状态；")]),_._v(" "),t("li",[_._v("当一个进程（线程）将操作系统分配的时间片段用完后，会回到“就绪”（Ready）状态。")])]),_._v(" "),t("p",[_._v("有时候一个进程（线程）会等待磁盘读取数据，或者等待打印机响应，此时进程自己会进入“阻塞”（Block）状态。")]),_._v(" "),t("h4",{attrs:{id:"进程-线程-切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程-线程-切换"}},[_._v("#")]),_._v(" 进程（线程）切换")]),_._v(" "),t("p",[_._v("进程（线程）在操作系统中是不断切换的，现代操作系统中只有线程的切换。 每次切换需要先保存当前寄存器的值的内存，注意 PC 指针也是一种寄存器。当恢复执行的时候，就需要从内存中读出所有的寄存器，恢复之前的状态，然后执行。")]),_._v(" "),t("p",[t("img",{attrs:{src:"http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/assets/CgqCHl-iUY-AEqrUAAKnDhPzBcQ340.png",alt:"Lark20201104-145523.png"}})]),_._v(" "),t("p",[_._v("上面讲到的内容，我们可以概括为以下 5 个步骤：")]),_._v(" "),t("ol",[t("li",[_._v("当操作系统发现一个进程（线程）需要被切换的时候，直接控制 PC 指针跳转是非常危险的事情，所以操作系统需要发送一个“中断”信号给 CPU，停下正在执行的进程（线程）。")]),_._v(" "),t("li",[_._v("当 CPU 收到中断信号后，正在执行的进程（线程）会立即停止。注意，因为进程（线程）马上被停止，它还来不及保存自己的状态，所以后续操作系统必须完成这件事情。")]),_._v(" "),t("li",[_._v("操作系统接管中断后，趁寄存器数据还没有被破坏，必须马上执行一小段非常底层的程序（通常是汇编编写），帮助寄存器保存之前进程（线程）的状态。")]),_._v(" "),t("li",[_._v("操作系统保存好进程状态后，执行调度程序，决定下一个要被执行的进程（线程）。")]),_._v(" "),t("li",[_._v("最后，操作系统执行下一个进程（线程）。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/assets/Ciqc1F-iUZ-Af-t9AAC3WjDjEM4772.png",alt:"Lark20201104-145556.png"}})]),_._v(" "),t("p",[_._v("当然，一个进程（线程）被选择执行后，它会继续完成之前被中断时的任务，这需要操作系统来执行一小段底层的程序帮助进程（线程）恢复状态。")]),_._v(" "),t("p",[t("img",{attrs:{src:"http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/assets/Ciqc1F-iUa-AdqG9AACMOQKJe2Q431.png",alt:"Lark20201104-145530.png"}})]),_._v(" "),t("p",[_._v("一种可能的算法就是通过栈这种数据结构。进程（线程）中断后，操作系统负责压栈关键数据（比如寄存器）。恢复执行时，操作系统负责出栈和恢复寄存器的值。")]),_._v(" "),t("h2",{attrs:{id:"进程通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程通信"}},[_._v("#")]),_._v(" 进程通信")]),_._v(" "),t("h3",{attrs:{id:"管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[_._v("#")]),_._v(" 管道")]),_._v(" "),t("p",[_._v("管道：随进程的创建而建立，随进程的结束而销毁。")]),_._v(" "),t("p",[_._v("在 linux 中")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v(' ps auxf | grep mysql\n \n echo "hello" > myPipe  # 将数据写进管道。程序会阻塞，只有当管道里的数据被读完后，程序才会正常继续。\n')])])]),t("h3",{attrs:{id:"消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[_._v("#")]),_._v(" 消息队列")]),_._v(" "),t("p",[_._v("消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。一是通信不及时，二是附件也有大小限制")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("缺点：\n\t1. 通信不及时\n\t2. 不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 \t\tLinux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。\n\t3. 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。\n\t\n优点：\n\t1. 可以频繁地交换数据\n\t2. 可以自定义数据类型\n")])])]),t("h3",{attrs:{id:"共享内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),t("p",[_._v("共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。")]),_._v(" "),t("p",[_._v("​\t\t对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。")]),_._v(" "),t("p",[_._v("共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到，大大提高了进程间通信的速度。")]),_._v(" "),t("img",{staticStyle:{zoom:"50%"},attrs:{src:"assert/进程通信.png"}}),_._v(" "),t("h3",{attrs:{id:"信号量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[_._v("#")]),_._v(" 信号量")]),_._v(" "),t("p",[_._v("信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。")]),_._v(" "),t("p",[_._v("用了共享内存通信方式，带来新的问题：如果多个进程同时修改同一个共享内存，很有可能发生冲突。例如两个进程都同时写一个地址，先写的进程会的内容会被覆盖。")]),_._v(" "),t("p",[_._v("为了防止多进程竞争共享资源而造成的数据错乱，需要一种保护机制，使得共享的资源在任意时刻只能被一个进程访问。"),t("strong",[_._v("信号量")]),_._v("就实现了这一保护机制。")]),_._v(" "),t("p",[_._v("信号量本质是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。")]),_._v(" "),t("p",[_._v("信号量表示资源的数量，控制信号量的方式有两种原子操作：")]),_._v(" "),t("ul",[t("li",[_._v("**P 操作：**将信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。")]),_._v(" "),t("li",[_._v("**V 操作：**将信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；")])]),_._v(" "),t("p",[_._v("P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。")]),_._v(" "),t("p",[t("strong",[_._v("具体过程：")])]),_._v(" "),t("ul",[t("li",[_._v("进程 A 在访问共享内存前，先执行 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。")]),_._v(" "),t("li",[_._v("若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为 -1，意味着临界资源已被占用，因此进程 B 被阻塞。")]),_._v(" "),t("li",[_._v("进程 A 访问完共享内存，执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。")])]),_._v(" "),t("p",[_._v("信号初始化为 "),t("code",[_._v("1")]),_._v("，代表着是"),t("strong",[_._v("互斥信号量")]),_._v("，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。")]),_._v(" "),t("p",[_._v("另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。")]),_._v(" "),t("p",[_._v("例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程相互合作、相互依赖，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 "),t("code",[_._v("0")]),_._v("。")]),_._v(" "),t("p",[t("strong",[_._v("具体过程：")])]),_._v(" "),t("ul",[t("li",[_._v("如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；")]),_._v(" "),t("li",[_._v("接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；")]),_._v(" "),t("li",[_._v("最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。")])]),_._v(" "),t("p",[_._v("可以发现，信号初始化为 "),t("code",[_._v("0")]),_._v("，就代表着是"),t("strong",[_._v("同步信号量")]),_._v("，它可以保证进程 A 应在进程 B 之前执行。")]),_._v(" "),t("h3",{attrs:{id:"信号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[_._v("#")]),_._v(" 信号")]),_._v(" "),t("p",[_._v("与其他通信机制不同的是，它可用于不同及其间的进程通信")]),_._v(" "),t("p",[_._v("上面说的进程间通信，都是常规状态下的工作模式。对于异常情况下的工作模式，需要用"),t("strong",[_._v("信号")]),_._v("的方式来通知进程。")]),_._v(" "),t("p",[_._v("信号跟信号量虽然名字相似，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。")]),_._v(" "),t("p",[_._v("在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。可以通过 kill -l 命令查看所有的信号.")]),_._v(" "),t("p",[_._v("运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如")]),_._v(" "),t("ul",[t("li",[_._v("Ctrl+C 产生 SIGINT 信号，表示终止该进程；")]),_._v(" "),t("li",[_._v("Ctrl+Z 产生 SIGINTSIGTSTP 信号，表示停止该进程，但还未结束；")])]),_._v(" "),t("p",[_._v("如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：")]),_._v(" "),t("ul",[t("li",[_._v("kill -9 1050 ，表示给 PID 为 1050 的进程发送 "),t("code",[_._v("SIGKILL")]),_._v(" 信号，用来立即结束该进程；")])]),_._v(" "),t("p",[_._v("所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。")]),_._v(" "),t("p",[_._v("信号是进程间通信机制中"),t("strong",[_._v("唯一的异步通信机制")]),_._v("，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("执行默认操作")]),_._v("。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。")]),_._v(" "),t("li",[t("strong",[_._v("捕捉信号")]),_._v("。我们可以为信号定义一个信号处理函数。当信号发生时，就执行相应的信号处理函数。")]),_._v(" "),t("li",[t("strong",[_._v("忽略信号")]),_._v("。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。")])]),_._v(" "),t("h3",{attrs:{id:"socket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[_._v("#")]),_._v(" socket")]),_._v(" "),t("p",[_._v("网络通信，比如我们常见的 http")]),_._v(" "),t("h2",{attrs:{id:"线程间的通信方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程间的通信方式"}},[_._v("#")]),_._v(" 线程间的通信方式")]),_._v(" "),t("ul",[t("li",[_._v("锁机制：包括互斥锁，条件变量，读写锁\n"),t("ul",[t("li",[_._v("互斥锁提供了以排他方式防止数据结构被并发修改的问题")]),_._v(" "),t("li",[_._v("读写锁运行多线程同时读共享数据，而对写操作是互斥的")]),_._v(" "),t("li",[_._v("条件变量可以以原子方式阻塞进程，知道某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。")])])]),_._v(" "),t("li",[_._v("信号量机制（Semaphore）：包括无名线程信号量和命名线程信号量")]),_._v(" "),t("li",[_._v("信号机制（Signal）：类似进程间的信号处理，线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。")])]),_._v(" "),t("h2",{attrs:{id:"jvm-中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-中"}},[_._v("#")]),_._v(" JVM 中")]),_._v(" "),t("blockquote",[t("p",[_._v("参考：http://www.moguit.cn/#/info?blogOid=695")])]),_._v(" "),t("p",[_._v("在Java程序中，当我们启动 main 函数时，其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。")]),_._v(" "),t("p",[t("strong",[_._v("线程")]),_._v("是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。")]),_._v(" "),t("p",[_._v("同类的多个线程"),t("strong",[_._v("共享")]),_._v("进程的"),t("strong",[_._v("堆")]),_._v("和"),t("strong",[_._v("方法区")]),_._v("资源，但每个线程"),t("strong",[_._v("私有程序计数器、虚拟机栈")]),_._v("和"),t("strong",[_._v("本地方法栈。")])]),_._v(" "),t("p",[_._v("系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，"),t("strong",[_._v("线程也被称为轻量级进程")]),_._v("。")]),_._v(" "),t("p",[t("img",{attrs:{src:"assert/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpeg",alt:""}})]),_._v(" "),t("p",[_._v("从上图可以看出：一个"),t("strong",[_._v("进程")]),_._v("中可以有多个"),t("strong",[_._v("线程")]),_._v("，多个线程"),t("strong",[_._v("共享")]),_._v("进程的"),t("strong",[_._v("堆")]),_._v("和"),t("strong",[_._v("方法区 (JDK1.8 之后的元空间)"),t("strong",[_._v("资源，但是每个线程")]),_._v("私有程序计数器")]),_._v("、"),t("strong",[_._v("虚拟机栈")]),_._v(" 和 "),t("strong",[_._v("本地方法栈")]),_._v("。")]),_._v(" "),t("ul",[t("li",[_._v("线程是进程划分成的更小的运行单位。")]),_._v(" "),t("li",[_._v("最大的不同在于基本上各"),t("strong",[_._v("进程")]),_._v("是独立的，而各"),t("strong",[_._v("线程")]),_._v("则不一定，因为同一进程中的线程极有可能会相互影响。")]),_._v(" "),t("li",[t("strong",[_._v("线程")]),_._v("执行开销小，但不利于资源的管理和保护；而"),t("strong",[_._v("进程")]),_._v("正相反。")])]),_._v(" "),t("h3",{attrs:{id:"多线程可能带来的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程可能带来的问题"}},[_._v("#")]),_._v(" 多线程可能带来的问题")]),_._v(" "),t("p",[_._v("并发编程的"),t("strong",[_._v("目的")]),_._v("就是为了能提高程序的执行效率和运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。")]),_._v(" "),t("h3",{attrs:{id:"线程的生命周期和状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期和状态"}},[_._v("#")]),_._v(" 线程的生命周期和状态")]),_._v(" "),t("p",[t("img",{attrs:{src:"assert/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81.png",alt:""}})]),_._v(" "),t("p",[t("img",{attrs:{src:"assert/%E6%B5%81%E7%A8%8B.png",alt:""}})]),_._v(" "),t("p",[_._v("线程创建之后它将处于 "),t("strong",[_._v("NEW（新建）")]),_._v(" 状态，调用 "),t("code",[_._v("start()")]),_._v(" 方法后开始运行，线程这时候处于 "),t("strong",[_._v("READY（可运行）")]),_._v(" 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 "),t("strong",[_._v("RUNNING（运行）")]),_._v(" 状态。")]),_._v(" "),t("p",[_._v("当线程执行 "),t("code",[_._v("wait()")]),_._v("方法之后，线程进入 "),t("strong",[_._v("WAITING（等待）")]),_._v(" 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 "),t("strong",[_._v("TIMED_WAITING(超时等待)")]),_._v(" 状态相当于在等待状态的基础上增加了超时限制，比如通过 "),t("code",[_._v("sleep（long millis）")]),_._v("方法或 "),t("code",[_._v("wait（long millis）")]),_._v("方法可以将 Java 线程置于 "),t("strong",[_._v("TIMED_WAITING（超时等待）")]),_._v(" 状态。当超时时间到达后 Java 线程将会返回到 **RUNNABLE （运行）**状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 "),t("strong",[_._v("BLOCKED（阻塞）")]),_._v(" 状态。线程在执行 Runnable 的"),t("code",[_._v("run()")]),_._v("方法之后将会进入到 "),t("strong",[_._v("TERMINATED（终止）")]),_._v(" 状态。")]),_._v(" "),t("h3",{attrs:{id:"线程死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程死锁"}},[_._v("#")]),_._v(" 线程死锁")]),_._v(" "),t("p",[_._v("多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。")]),_._v(" "),t("p",[t("img",{attrs:{src:"assert/%E6%AD%BB%E9%94%81.png",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"产生死锁必须具备以下四个条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#产生死锁必须具备以下四个条件"}},[_._v("#")]),_._v(" 产生死锁必须具备以下四个条件：")]),_._v(" "),t("ol",[t("li",[_._v("互斥条件：该资源任意一个时刻只由一个线程占用。")]),_._v(" "),t("li",[_._v("请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。")]),_._v(" "),t("li",[_._v("不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。")]),_._v(" "),t("li",[_._v("循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。")])]),_._v(" "),t("h4",{attrs:{id:"预防和避免线程死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预防和避免线程死锁"}},[_._v("#")]),_._v(" 预防和避免线程死锁")]),_._v(" "),t("h5",{attrs:{id:"_1-如何预防死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何预防死锁"}},[_._v("#")]),_._v(" 1.如何预防死锁？")]),_._v(" "),t("p",[_._v("破坏死锁的产生的必要条件即可：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("破坏请求与保持条件")]),_._v(" ：一次性申请所有的资源。")]),_._v(" "),t("li",[t("strong",[_._v("破坏不剥夺条件")]),_._v(" ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。")]),_._v(" "),t("li",[t("strong",[_._v("破坏循环等待条件")]),_._v(" ：靠按序申请资源来预防。"),t("strong",[_._v("按某一顺序")]),_._v("申请资源，释放资源则"),t("strong",[_._v("反序")]),_._v("释放。")])]),_._v(" "),t("h5",{attrs:{id:"如何避免死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何避免死锁"}},[_._v("#")]),_._v(" 如何避免死锁？")]),_._v(" "),t("p",[_._v("在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。")]),_._v(" "),t("p",[_._v("安全状态指的是系统能够"),t("strong",[_._v("按照某种进程推进顺序")]),_._v("来为每个进程分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利完成。")]),_._v(" "),t("h1",{attrs:{id:"io多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[_._v("#")]),_._v(" IO多路复用")]),_._v(" "),t("p",[_._v("处理 I/O 多路复用的问题，需要操作系统提供内核级别的支持。Linux 下有三种提供 I/O 多路复用的 API，分别是：")]),_._v(" "),t("ul",[t("li",[_._v("select")]),_._v(" "),t("li",[_._v("poll")]),_._v(" "),t("li",[_._v("epoll")])]),_._v(" "),t("p",[_._v("如下图所示，内核了解网络的状态。因此不难知道具体发生了什么消息，比如内核知道某个 Socket 文件状态发生了变化。但是内核如何知道该把哪个消息给哪个进程呢？")]),_._v(" "),t("p",[t("img",{attrs:{src:"http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/assets/Ciqc1GABP5KAVSWVAAFSurtl2bU931.png",alt:"Lark20210115-150654.png"}})]),_._v(" "),t("p",[t("strong",[_._v("一个 Socket 文件，可以由多个进程使用；而一个进程，也可以使用多个 Socket 文件")]),_._v("。进程和 Socket 之间是多对多的关系。"),t("strong",[_._v("另一方面，一个 Socket 也会有不同的事件类型")]),_._v("。因此操作系统很难判断，将哪样的事件给哪个进程。")]),_._v(" "),t("p",[_._v("这样"),t("strong",[_._v("在进程内部就需要一个数据结构来描述自己会关注哪些 Socket 文件的哪些事件（读、写、异常等")]),_._v("）。通常有两种考虑方向，"),t("strong",[_._v("一种是利用线性结构")]),_._v("，比如说数组、链表等，这类结构的查询需要遍历。每次内核产生一种消息，就遍历这个线性结构。看看这个消息是不是进程关注的？"),t("strong",[_._v("另一种是索引结构")]),_._v("，内核发生了消息可以通过索引结构马上知道这个消息进程关不关注。")]),_._v(" "),t("h4",{attrs:{id:"select"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[_._v("#")]),_._v(" select()")]),_._v(" "),t("p",[_._v("select 和 poll 都采用线性结构，select 允许用户传入 3 个集合。如下面这段程序所示：")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("fd_set read_fd_set, write_fd_set, error_fd_set;\n\nwhile(true) {\n\n  select(..., &read_fd_set, &write_fd_set, &error_fd_set); \n\n}\n")])])]),t("p",[t("strong",[_._v("每次 select 操作会阻塞当前线程，在阻塞期间所有操作系统产生的每个消息，都会通过遍历的手段查看是否在 3 个集合当中")]),_._v("。上面程序"),t("code",[_._v("read_fd_set")]),_._v("中放入的是当数据可以读取时进程关心的 Socket；"),t("code",[_._v("write_fd_set")]),_._v("是当数据可以写入时进程关心的 Socket；"),t("code",[_._v("error_fd_set")]),_._v("是当发生异常时进程关心的 Socket。")]),_._v(" "),t("p",[_._v("**用户程序可以根据不同集合中是否有某个 Socket 判断发生的消息类型，**程序如下所示：")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("fd_set read_fd_set, write_fd_set, error_fd_set;\n\nwhile(true) {\n\n  select(..., &read_fd_set, &write_fd_set, &error_fd_set); \n\n  for (i = 0; i < FD_SETSIZE; ++i)\n\n        if (FD_ISSET (i, &read_fd_set)){\n\n          // Socket可以读取\n\n        } else if(FD_ISSET(i, &write_fd_set)) {\n\n          // Socket可以写入\n\n        } else if(FD_ISSET(i, &error_fd_set)) {\n\n          // Socket发生错误\n\n        } \n\n}\n")])])]),t("p",[_._v("上面程序中的 FD_SETSIZE 是一个系统的默认设置，通常是 1024。可以看出，select 模式能够一次处理的文件描述符是有上限的，也就是 FD_SETSIZE。当并发请求过多的时候， select 就无能为力了。但是对单台机器而言，1024 个并发已经是一个非常大的流量了。")]),_._v(" "),t("p",[_._v("在上面的模型当中，select/poll 是阻塞（Blocking）模型，epoll 是非阻塞（Non-Blocking）模型。"),t("strong",[_._v("阻塞和非阻塞强调的是线程的状态")]),_._v("，所以阻塞就是触发了线程的阻塞状态，线程阻塞了就停止执行，并且切换到其他线程去执行，直到触发中断再回来。")]),_._v(" "),t("p",[_._v("还有一组概念是同步（Synchrounous）和异步（Asynchrounous），select/poll/epoll 三者都是同步调用。")]),_._v(" "),t("p",[_._v("**同步强调的是顺序，**所谓同步调用，就是可以确定程序执行的顺序的调用。比如说执行一个调用，知道调用返回之前下一行代码不会执行。这种顺序是确定的情况，就是同步。")]),_._v(" "),t("p",[_._v("而异步调用则恰恰相反，"),t("strong",[_._v("异步调用不明确执行顺序")]),_._v("。比如说一个回调函数，不知道何时会回来。异步调用会加大程序员的负担，因为我们习惯顺序地思考程序。因此，我们还会发明像协程的 yield 、迭代器等将异步程序转为同步程序。")]),_._v(" "),t("p",[_._v("由此可见，"),t("strong",[_._v("非阻塞不一定是异步，阻塞也未必就是同步")]),_._v("。比如一个带有回调函数的方法，阻塞了线程 100 毫秒，又提供了回调函数，那这个方法是异步阻塞。")]),_._v(" "),t("p",[_._v("poll 虽然优化了编程模型，但是从性能角度分析，它和 select 差距不大。因为内核在产生一个消息之后，依然需要遍历 poll 关注的所有文件描述符来确定这条消息是否跟用户程序相关。")]),_._v(" "),t("h4",{attrs:{id:"poll"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[_._v("#")]),_._v(" poll()")]),_._v(" "),t("p",[_._v("从写程序的角度来看，select 并不是一个很好的编程模型。一个好的编程模型应该直达本质，当网络请求发生状态变化的时候，核心是会发生事件。"),t("strong",[_._v("一个好的编程模型应该是直接抽象成消息：用户不需要用 select 来设置自己的集合，而是可以通过系统的 API 直接拿到对应的消息，从而处理对应的文件描述符")]),_._v("。")]),_._v(" "),t("p",[_._v("比如下面这段伪代码就是一个更好的编程模型，具体的分析如下：")]),_._v(" "),t("ul",[t("li",[_._v("poll 是一个阻塞调用，它将某段时间内操作系统内发生的且进程关注的消息告知用户程序；")]),_._v(" "),t("li",[_._v("用户程序通过直接调用 poll 函数拿到消息；")]),_._v(" "),t("li",[_._v("poll 函数的第一个参数告知内核 poll 关注哪些 Socket 及消息类型；")]),_._v(" "),t("li",[_._v("poll 调用后，经过一段时间的等待（阻塞），就拿到了是一个消息的数组；")]),_._v(" "),t("li",[_._v("通过遍历这个数组中的消息，能够知道关联的文件描述符和消息的类型；")]),_._v(" "),t("li",[_._v("通过消息类型判断接下来该进行读取还是写入操作；")]),_._v(" "),t("li",[_._v("通过文件描述符，可以进行实际地读、写、错误处理。")])]),_._v(" "),t("h4",{attrs:{id:"epoll"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[_._v("#")]),_._v(" epoll")]),_._v(" "),t("p",[_._v("为了解决上述问题，"),t("strong",[_._v("epoll 通过更好的方案实现了从操作系统订阅消息。epoll 将进程关注的文件描述符存入一棵二叉搜索树，通常是红黑树的实现")]),_._v("。在这棵红黑树当中，Key 是 Socket 的编号，值是这个 Socket 关注的消息。因此，当内核发生了一个事件：比如 Socket 编号 1000 可以读取。这个时候，可以马上从红黑树中找到进程是否关注这个事件。")]),_._v(" "),t("p",[t("strong",[_._v("另外当有关注的事件发生时，epoll 会先放到一个队列当中。当用户调用")]),t("code",[_._v("epoll_wait")]),_._v("时候，就会从队列中返回一个消息。epoll 函数本身是一个构造函数，只用来创建红黑树和队列结构。"),t("code",[_._v("epoll_wait")]),_._v("调用后，如果队列中没有消息，也可以马上返回。因此"),t("code",[_._v("epoll")]),_._v("是一个非阻塞模型。")]),_._v(" "),t("p",[t("strong",[_._v("总结一下，select/poll 是阻塞模型，epoll 是非阻塞模型")]),_._v("。"),t("strong",[_._v("当然，并不是说非阻塞模型性能就更好。在多数情况下，epoll 性能更好是因为内部有红黑树的实现")]),_._v("。")]),_._v(" "),t("p",[_._v("最后我再贴一段用 epoll 实现的 Socket 服务给你做参考，这段程序的作者将这段代码放到了 Public Domain，你以后看到公有领域的代码可以放心地使用。")]),_._v(" "),t("p",[_._v("下面这段程序跟之前 select 的原理一致，对于每一个新的客户端连接，都使用 accept 拿到这个连接的文件描述符，并且创建一个客户端的 Socket。然后通过"),t("code",[_._v("epoll_ctl")]),_._v("将客户端的文件描述符和关注的消息类型放入 epoll 的红黑树。操作系统每次监测到一个新的消息产生，就会通过红黑树对比这个消息是不是进程关注的（当然这段代码你看不到，因为它在内核程序中）。")]),_._v(" "),t("p",[t("strong",[_._v("非阻塞模型的核心价值，并不是性能更好。当真的高并发来临的时候，所有的 CPU 资源，所有的网络资源可能都会被用完。这个时候无论是阻塞还是非阻塞，结果都不会相差太大")]),_._v("。（前提是程序没有写错）。")]),_._v(" "),t("p",[t("code",[_._v("epoll")]),_._v("有 2 个最大的优势：")]),_._v(" "),t("ol",[t("li",[_._v("内部使用红黑树减少了内核的比较操作；")]),_._v(" "),t("li",[_._v("对于程序员而言，非阻塞的模型更容易处理各种各样的情况。程序员习惯了写出每一条语句就可以马上得到结果，这样不容易出 Bug。")])]),_._v(" "),t("p",[t("strong",[_._v("select/poll/epoll 有什么区别")]),_._v("？")]),_._v(" "),t("p",[_._v("【"),t("strong",[_._v("解析")]),_._v("】这三者都是处理 I/O 多路复用的编程手段。select/poll 模型是一种阻塞模型，epoll 是非阻塞模型。select/poll 内部使用线性结构存储进程关注的 Socket 集合，因此每次内核要判断某个消息是否发送给 select/poll 需要遍历进程关注的 Socket 集合。")]),_._v(" "),t("p",[_._v("而 epoll 不同，epoll 内部使用二叉搜索树（红黑树），用 Socket 编号作为索引，用关注的事件类型作为值，这样内核可以在非常快的速度下就判断某个消息是否需要发送给使用 epoll 的线程。")])])}),[],!1,null,null,null);v.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{416:function(v,_,e){"use strict";e.r(_);var s=e(56),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"_1-nosql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-nosql"}},[v._v("#")]),v._v(" 1. NoSQL")]),v._v(" "),e("h2",{attrs:{id:"_1-1-nosql-概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-nosql-概述"}},[v._v("#")]),v._v(" 1.1 NoSQL 概述")]),v._v(" "),e("p",[v._v("NoSQL(NoSQL = "),e("strong",[v._v("Not Only SQL")]),v._v(" )，意即“不仅仅是SQL”，泛指"),e("strong",[v._v("非关系型的数据库")]),v._v("。")]),v._v(" "),e("p",[v._v("NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。")]),v._v(" "),e("blockquote",[e("p",[v._v("NoSQL数据库概述")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("不遵循SQL标准。")])]),v._v(" "),e("li",[e("p",[v._v("不支持ACID。")])]),v._v(" "),e("li",[e("p",[v._v("远超于SQL的性能。")])])]),v._v(" "),e("blockquote",[e("p",[v._v("NoSQL适用场景")])]),v._v(" "),e("ul",[e("li",[v._v("对数据高并发的读写")]),v._v(" "),e("li",[v._v("海量数据的读写")]),v._v(" "),e("li",[v._v("对数据高可扩展性的")])]),v._v(" "),e("blockquote",[e("p",[v._v("NoSQL 不适用场景")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("需要事务支持")])]),v._v(" "),e("li",[e("p",[v._v("基于sql的结构化查询存储，处理复杂的关系,需要即席查询。")])]),v._v(" "),e("li",[e("p",[v._v("（用不着sql 的和用了sql 也不行的情况，请考虑用NoSql）")])])]),v._v(" "),e("h2",{attrs:{id:"_1-2-常用的nosql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-常用的nosql"}},[v._v("#")]),v._v(" 1.2 常用的NoSQL")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("软件")]),v._v(" "),e("th",[v._v("用途")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("Memcache")]),v._v(" "),e("td",[v._v("- 很早出现的NoSql数据库"),e("br"),v._v("- 数据都在内存中，一般不持久化"),e("br"),v._v("- 支持简单的key-value模式，支持类型单一  "),e("br"),v._v("- 一般是作为缓存数据库辅助持久化的数据库")])]),v._v(" "),e("tr",[e("td",[v._v("Redis")]),v._v(" "),e("td",[v._v("- 几乎覆盖了Memcached的绝大部分功能"),e("br"),v._v("- 数据都在内存中，支持持久化，主要用作备份恢复"),e("br"),v._v("- 除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。"),e("br"),v._v("- 一般是作为缓存数据库辅助持久化的数据库")])]),v._v(" "),e("tr",[e("td",[v._v("MongoDB")]),v._v(" "),e("td",[v._v("- 高性能、开源、模式自由(schema free)的"),e("strong",[v._v("文档型数据库")]),e("br"),v._v("- 数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘"),e("br"),v._v("- 虽然是key-value模式，但是对value（尤其是"),e("strong",[v._v("json")]),v._v("）提供了丰富的查询功能 "),e("br"),v._v("- 支持二进制数据及大型对象"),e("br"),v._v("- 可以根据数据的特点"),e("strong",[v._v("替代RDBMS")]),v._v(" ，成为独立的数据库。或者配合RDBMS，存储特定的数据。")])])])]),v._v(" "),e("h1",{attrs:{id:"_2-redis概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis概述"}},[v._v("#")]),v._v(" 2. redis概述")]),v._v(" "),e("h2",{attrs:{id:"_2-1-redis-知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-redis-知识"}},[v._v("#")]),v._v(" 2.1 redis 知识")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Redis是一个开源的 "),e("strong",[v._v("key-value")]),v._v(" 存储系统。")])]),v._v(" "),e("li",[e("p",[v._v("和Memcached类似，它支持存储的value类型相对更多，包括 "),e("strong",[v._v("string")]),v._v(" (字符串)、"),e("strong",[v._v("list")]),v._v(" (链表)、"),e("strong",[v._v("set")]),v._v("(集合)、"),e("strong",[v._v("zset")]),v._v(" (sorted set --有序集合)和 "),e("strong",[v._v("hash")]),v._v("（哈希类型）。")])]),v._v(" "),e("li",[e("p",[v._v("这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是 "),e("strong",[v._v("原子性")]),v._v(" 的。")])]),v._v(" "),e("li",[e("p",[v._v("在此基础上，Redis支持各种不同方式的"),e("strong",[v._v("排序")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("与memcached一样，为了保证效率，"),e("strong",[v._v("数据都是缓存在内存中")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("区别的是Redis会"),e("strong",[v._v("周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件")]),v._v("。")])]),v._v(" "),e("li",[e("p",[v._v("并且在此基础上实现了"),e("strong",[v._v("master-slave(主从)同步")]),v._v("。")])])]),v._v(" "),e("p",[e("strong",[v._v("多样的数据结构存储持久化数据")])]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/1.png"}}),v._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/2.png"}}),v._v(" "),e("p",[v._v("redis  默认16个数据库，类似数组下标从0开始，初始默认使用0号库  使用命令 select  "),e("dbid",[v._v("来切换数据库。如: select 8   统一密码管理，所有库同样密码。")])],1),v._v(" "),e("ul",[e("li",[e("p",[v._v("select index 切换数据库")])]),v._v(" "),e("li",[e("p",[v._v("dbsize查看当前数据库的key的数量")])]),v._v(" "),e("li",[e("p",[v._v("flushdb清空当前库")])]),v._v(" "),e("li",[e("p",[v._v("flushall通杀全部库")])])]),v._v(" "),e("p",[v._v("Redis是单线程+多路IO复用技术")]),v._v(" "),e("p",[v._v("多路复用是指使用 "),e("strong",[v._v("一个线程来检查多个文件描述符（Socket）的就绪状态")]),v._v(" ，比如调用select和poll函数，传入多个文件描述符，"),e("strong",[v._v("如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）")])]),v._v(" "),e("p",[v._v("串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)")]),v._v(" "),e("p",[v._v("（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）")]),v._v(" "),e("h2",{attrs:{id:"_2-2-redis命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-redis命令"}},[v._v("#")]),v._v(" 2.2 redis命令")]),v._v(" "),e("p",[v._v("官网：http://www.redis.cn/commands.html")]),v._v(" "),e("p",[v._v("###2.2.1 key操作")]),v._v(" "),e("p",[v._v("keys *查看当前库所有key  (匹配：keys *1)")]),v._v(" "),e("p",[v._v("exists key判断某个key是否存在")]),v._v(" "),e("p",[v._v("type key 查看你的key是什么类型")]),v._v(" "),e("p",[v._v("del key    删除指定的key数据")]),v._v(" "),e("p",[e("strong",[v._v("unlink key  根据value选择非阻塞删除")])]),v._v(" "),e("p",[v._v("仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。")]),v._v(" "),e("p",[v._v("expire key 10  10秒钟：为给定的key设置过期时间")]),v._v(" "),e("p",[e("strong",[v._v("ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期")]),v._v("，当直接设置键值时默认永不过期 "),e("code",[v._v("set key value")])]),v._v(" "),e("p",[v._v("select命令切换数据库")]),v._v(" "),e("p",[v._v("dbsize查看当前数据库的key的数量")]),v._v(" "),e("p",[v._v("flushdb清空当前库")]),v._v(" "),e("p",[v._v("flushall通杀全部库")]),v._v(" "),e("h3",{attrs:{id:"_2-2-2-string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-string"}},[v._v("#")]),v._v(" 2.2.2 string")]),v._v(" "),e("p",[v._v("String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。")]),v._v(" "),e("p",[v._v("String类型是"),e("strong",[v._v("二进制安全")]),v._v("的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。")]),v._v(" "),e("p",[v._v("String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是 "),e("strong",[v._v("512M")])]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/3.png",alt:""}})]),v._v(" "),e("ul",[e("li",[e("p",[v._v("set  "),e("key",[e("value",[v._v("添加键值对")])],1)],1),v._v(" "),e("ul",[e("li",[v._v("NX：当数据库中key不存在时，可以将key-value添加数据库")]),v._v(" "),e("li",[v._v("XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥")]),v._v(" "),e("li",[v._v("EX：key的超时秒数")]),v._v(" "),e("li",[v._v("PX：key的超时毫秒数，与EX互斥")])])]),v._v(" "),e("li",[e("p",[v._v("get  "),e("key",[v._v("查询对应键值")])],1)]),v._v(" "),e("li",[e("p",[v._v("append "),e("key",[e("value",[v._v("将给定的"),e("value",[v._v(" 追加到原值的末尾")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("strlen "),e("key",[v._v("获得值的长度")])],1)]),v._v(" "),e("li",[e("p",[v._v("setnx "),e("key",[e("value",[v._v("只有在 key 不存在时  设置 key 的值")])],1)],1)])]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/4.png"}}),v._v(" "),e("ul",[e("li",[e("p",[v._v("incr "),e("key",[v._v("：将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1")])],1)]),v._v(" "),e("li",[e("p",[v._v("decr "),e("key",[v._v("：将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1")])],1)]),v._v(" "),e("li",[e("p",[v._v("incrby / decrby "),e("key",[v._v("<步长>将 key 中储存的数字值增减。自定义步长。")])],1)]),v._v(" "),e("li",[e("p",[v._v("mset "),e("key1",[e("value1",[e("key2",[e("value2",[v._v(" ..... ：同时设置一个或多个 key-value对")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("mget "),e("key1",[e("key2",[e("key3",[v._v(" .....：同时获取一个或多个 value")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("msetnx "),e("key1",[e("value1",[e("key2",[e("value2",[v._v(" ..... ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。"),e("strong",[v._v("原子性，有一个失败则都失败")])])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("getrange "),e("key",[v._v("<起始位置><结束位置>：获得值的范围，类似java中的substring，"),e("strong",[v._v("前包，后包")])])],1)]),v._v(" "),e("li",[e("p",[v._v("setrange "),e("key",[v._v("<起始位置>"),e("value",[v._v("：用 "),e("value",[v._v(" 覆写"),e("key",[v._v("所储存的字符串值，从<起始位置>开始("),e("strong",[v._v("索引从0****开始")]),v._v(")。")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[e("strong",[v._v("setex <过期时间>")]),v._v("：设置键值的同时，设置过期时间，单位秒。")])]),v._v(" "),e("li",[e("p",[v._v("getset "),e("key",[e("value",[v._v("：以新换旧，设置了新值同时获得旧值。")])],1)],1)])]),v._v(" "),e("p",[e("strong",[v._v("String 的数据结构")])]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/6.png"}}),v._v(" "),e("p",[e("strong",[v._v("原子性")])]),v._v(" "),e("p",[v._v("所谓"),e("strong",[v._v("原子")]),v._v("操作是指不会被线程调度机制打断的操作；")]),v._v(" "),e("p",[v._v("这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。")]),v._v(" "),e("p",[v._v('（1）在单线程中， 能够在单条指令中完成的操作都可以认为是"原子操作"，因为中断只能发生于指令之间。')]),v._v(" "),e("p",[v._v("（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。")]),v._v(" "),e("p",[v._v("Redis单命令的原子性主要得益于Redis的单线程。")]),v._v(" "),e("p",[v._v("redis由于 单线程，所以 i++是原子性操作")]),v._v(" "),e("p",[v._v("但是，在 java中，由于 java 是多线程操作")]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/5.png"}}),v._v(" "),e("h3",{attrs:{id:"_2-2-3-list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-list"}},[v._v("#")]),v._v(" 2.2.3 list")]),v._v(" "),e("p",[v._v("单键多值")]),v._v(" "),e("p",[v._v("Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。")]),v._v(" "),e("p",[v._v("它的底层实际是个"),e("strong",[v._v("双向链表")]),v._v(" ，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/7.png",alt:""}})]),v._v(" "),e("ul",[e("li",[e("p",[v._v("lpush/rpush "),e("key",[e("value1",[e("value2",[e("value3",[v._v(" .... 从左边/右边插入一个或多个值。")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("lpop/rpop "),e("key",[v._v("从左边/右边吐出一个值。值在键在，值光键亡。")])],1)]),v._v(" "),e("li",[e("p",[v._v("rpoplpush "),e("key1",[e("key2",[v._v("从"),e("key1",[v._v("列表右边吐出一个值，插到"),e("key2",[v._v("列表左边。")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("lrange "),e("key",[e("start",[e("stop",[v._v("：按照索引下标获得元素(从左到右)")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("lrange mylist 0 -1  0左边第一个，-1右边第一个，（0-1表示获取所有）")])]),v._v(" "),e("li",[e("p",[v._v("lindex "),e("key",[e("index",[v._v("按照索引下标获得元素(从左到右)")])],1)],1)]),v._v(" "),e("li",[e("p",[v._v("llen "),e("key",[v._v("获得列表长度")])],1)]),v._v(" "),e("li",[e("p",[v._v("linsert "),e("key",[v._v(" before "),e("value",[e("newvalue",[v._v("在"),e("value",[v._v("的后面插入"),e("newvalue",[v._v("插入值")])],1)],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("lrem "),e("key",[e("n",[e("value",[v._v("从左边删除n个value(从左到右)")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("lset"),e("key",[e("index",[e("value",[v._v("将列表key下标为index的值替换成value")])],1)],1)],1)])]),v._v(" "),e("p",[e("strong",[v._v("数据结构")])]),v._v(" "),e("p",[v._v("List的数据结构为快速链表quickList。")]),v._v(" "),e("p",[v._v("首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。")]),v._v(" "),e("p",[v._v("它将所有的元素紧挨着一起存储，分配的是一块连续的内存。")]),v._v(" "),e("p",[v._v("当数据量比较多的时候才会改成quicklist。")]),v._v(" "),e("p",[v._v("因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/8.png",alt:""}})]),v._v(" "),e("p",[v._v("Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。")]),v._v(" "),e("h3",{attrs:{id:"_2-2-4-set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-4-set"}},[v._v("#")]),v._v(" 2.2.4 set")]),v._v(" "),e("p",[v._v("Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以"),e("strong",[v._v("自动排重")]),v._v("的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。")]),v._v(" "),e("p",[v._v("Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的"),e("strong",[v._v("复杂度都是O(1)")]),v._v("。")]),v._v(" "),e("p",[v._v("一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("sadd "),e("key",[e("value1",[e("value2",[v._v(" ..... ：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("smembers "),e("key",[v._v("取出该集合的所有值。")])],1)]),v._v(" "),e("li",[e("p",[v._v("sismember "),e("key",[e("value",[v._v("判断集合"),e("key",[v._v("是否为含有该"),e("value",[v._v("值，有1，没有0")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("scard"),e("key",[v._v("返回该集合的元素个数。")])],1)]),v._v(" "),e("li",[e("p",[v._v("srem "),e("key",[e("value1",[e("value2",[v._v(" .... 删除集合中的某个元素。")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("spop "),e("key",[e("strong",[v._v("随机从该集合中吐出一个值。")])])],1)]),v._v(" "),e("li",[e("p",[v._v("srandmember "),e("key",[e("n",[v._v("随机从该集合中取出n个值。不会从集合中删除 。")])],1)],1)]),v._v(" "),e("li",[e("p",[v._v("smove ")]),e("source"),e("destination",[v._v("value把集合中一个值从一个集合移动到另一个集合"),e("p")])],1),v._v(" "),e("li",[e("p",[v._v("sinter "),e("key1",[e("key2",[v._v("返回两个集合的交集元素。")])],1)],1)]),v._v(" "),e("li",[e("p",[v._v("sunion "),e("key1",[e("key2",[v._v("返回两个集合的并集元素。")])],1)],1)]),v._v(" "),e("li",[e("p",[v._v("sdiff "),e("key1",[e("key2",[v._v("返回两个集合的"),e("strong",[v._v("差集")]),v._v("元素(key1中的，不包含key2中的)")])],1)],1)])]),v._v(" "),e("p",[e("strong",[v._v("数据结构")])]),v._v(" "),e("p",[v._v("Set数据结构是dict字典，字典是用哈希表实现的。")]),v._v(" "),e("p",[v._v("Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。")]),v._v(" "),e("h3",{attrs:{id:"_2-2-5-hash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-5-hash"}},[v._v("#")]),v._v(" 2.2.5 hash")]),v._v(" "),e("p",[v._v("Redis hash 是一个键值对集合。")]),v._v(" "),e("p",[v._v("Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。")]),v._v(" "),e("p",[v._v("类似Java里面的Map<String,Object>")]),v._v(" "),e("p",[v._v("用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储")]),v._v(" "),e("p",[v._v("主要有以下2种存储方式：")]),v._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://cdn.jsdelivr.net/gh/winden96/jsdelivr@1.0/Redis/assert/9.png"}}),v._v(" "),e("ul",[e("li",[e("p",[v._v("hset "),e("key",[e("field",[e("value",[v._v("给"),e("key",[v._v("集合中的 "),e("field",[v._v("键赋值"),e("value")],1)],1)],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("hget "),e("key1",[e("field",[v._v("从"),e("key1",[v._v("集合"),e("field",[v._v("取出 value")])],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("hmset "),e("key1",[e("field1",[e("value1",[e("field2",[e("value2",[v._v("... 批量设置hash的值")])],1)],1)],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("hexists"),e("key1",[e("field",[v._v("查看哈希表 key 中，给定域 field 是否存在。")])],1)],1)]),v._v(" "),e("li",[e("p",[v._v("hkeys "),e("key",[v._v("列出该hash集合的所有field")])],1)]),v._v(" "),e("li",[e("p",[v._v("hvals "),e("key",[v._v("列出该hash集合的所有value")])],1)]),v._v(" "),e("li",[e("p",[v._v("hincrby "),e("key",[e("field",[e("increment",[v._v("为哈希表 key 中的域 field 的值加上增量 1  -1")])],1)],1)],1)]),v._v(" "),e("li",[e("p",[v._v("hsetnx "),e("key",[e("field",[e("value",[v._v("将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .")])],1)],1)],1)])]),v._v(" "),e("p",[e("strong",[v._v("数据结构")])]),v._v(" "),e("p",[v._v("​\tHash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。")]),v._v(" "),e("h3",{attrs:{id:"_2-2-6-zset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-6-zset"}},[v._v("#")]),v._v(" 2.2.6 zset")]),v._v(" "),e("p",[v._v("​\tRedis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。")]),v._v(" "),e("p",[v._v("不同之处是有序集合的每个成员都关联了一个"),e("strong",[v._v("评分（"),e("strong",[e("strong",[v._v("score")])]),v._v("）")]),v._v(",这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。")]),v._v(" "),e("p",[v._v("因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。")]),v._v(" "),e("p",[v._v("访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。")]),v._v(" "),e("h1",{attrs:{id:"_3-缓存穿透"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓存穿透"}},[v._v("#")]),v._v(" 3. 缓存穿透")]),v._v(" "),e("p",[v._v("可能存在一些非法用户，他可能会模拟出很多不存在的key，然后通过该key去请求后台，首先redis的缓存没有命中，那么就去请求数据库，最后数据库没有查询出该内容，这样很多个非法的请求直接打在数据库中，可能会导致数据库直接宕机，无法对外提供服务。这就是我们所说的缓存穿透问题")]),v._v(" "),e("p",[v._v("当数据量较小的时候可以设置 null，较大的时候设置 布隆过滤器")]),v._v(" "),e("ul",[e("li",[v._v("设置 null")])]),v._v(" "),e("p",[v._v("针对这个情况，我们有一种简单的解决方法就是，在数据库没有查询该条数据的时候，我们让该key缓存一个 空数据，这样用户再次以该key请求后台的时候，会直接返回null，避免了再次请求数据库。")]),v._v(" "),e("ul",[e("li",[v._v("布隆过滤器")])]),v._v(" "),e("p",[v._v("布隆过滤器的巨大作用 ，就是能够迅速判断一个元素是否存在一个集合中。因此次他有如下几个使用场景")]),v._v(" "),e("ul",[e("li",[v._v("网站爬虫对URL的去重，避免爬取相同的URL")]),v._v(" "),e("li",[v._v("反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否是垃圾邮件（同理，垃圾短信）")]),v._v(" "),e("li",[v._v("缓存穿透，将所有可能的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时，迅速返回避免缓存以及DB挂掉。")])]),v._v(" "),e("p",[v._v("详见 Redis中")])])}),[],!1,null,null,null);_.default=t.exports}}]);